// MIT License
//
// File: ipopt_ts_spcast_v3.cpp
//
// PURPOSE:
//   - Read a PCAP/PCAPNG file and walk packets with a 2-packet sliding window.
//   - For UDP packets carrying Spcast V3, extract 8-byte send_timestamp_ns and
//     write ONLY the *next* packet's timestamp into an IPv4 option on the *current* packet.
//   - Optionally rewrite the IPv4 destination multicast group and UDP destination port,
//     and (optionally) rewrite the Ethernet destination MAC to match the new multicast IP.
//   - Recompute all dependent fields (IPv4 total length & checksum, UDP checksum).
//
// BUILD (Linux/macOS):
//   g++ -O2 -std=c++17 ipopt_ts_spcast_v3.cpp \
//       -lPcap++ -lPacket++ -lCommon++ -lpcap -lpthread -o ipopt_ts_spcast_v3
//
// USAGE:
//   ./ipopt_ts_spcast_v3 in.pcap out.pcap [options]
//     --same-flow            Only use next packet if same 5-tuple
//     --send-off N           Offset of send_timestamp_ns in UDP payload (default: 9)
//     --rewrite-mgroup IP    Overwrite IPv4 dst to this (multicast) group for UDP packets
//     --rewrite-dport N      Overwrite UDP dst port for UDP packets
//     --rewrite-l2           Also rewrite Ethernet dst MAC to match the new multicast IP
//
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <arpa/inet.h>

#include "PcapFileDevice.h"
#include "Packet.h"
#include "IPv4Layer.h"
#include "UdpLayer.h"
#include "EthLayer.h"

using namespace pcpp;

// Deduce the IPv4 option enum type in a portable way across PcapPlusPlus versions.
using IPv4OptEnum = decltype(IPV4OPT_NOP);
// Use an experimental/private-use option number (RFC 3692-style). Decimal 30 (0x1E).
static constexpr IPv4OptEnum kOurIpv4OptType = static_cast<IPv4OptEnum>(30);

// ---------------- Configuration ----------------
static IPv4Address g_newDstGroup;             // multicast group to overwrite to
static bool        g_haveNewDstGroup = false;
static uint16_t    g_newDstPort      = 0;     // 0 = no change
static bool        g_rewriteL2       = false; // also rewrite Ethernet dest MAC
static size_t      g_spcast_send_off = 9;     // Spcast V3 send_timestamp_ns offset (ver:1, recv:8, send:8)
static bool        g_requireSameFlow = false;

// ---------------- Spcast V3 extraction ----------------
static constexpr uint8_t SPCAST_V3_VERSION = 3;
static constexpr size_t  MIN_SPCAST_HDR    = 1 + 8 + 8; // ver + recv + send

static bool extract_spcast_send_ts8(Packet& pkt, uint8_t out[8]) {
    UdpLayer* udp = pkt.getLayerOfType<UdpLayer>();
    if (!udp) return false;
    const uint8_t* payload = udp->getLayerPayload();
    size_t payloadLen = udp->getLayerPayloadSize();
    if (!payload || payloadLen < MIN_SPCAST_HDR) return false;
    if (payload[0] != SPCAST_V3_VERSION) return false;
    if (payloadLen < g_spcast_send_off + 8) return false;
    std::memcpy(out, payload + g_spcast_send_off, 8);
    return true;
}

// ---------------- Helpers ----------------
static bool isMulticastIPv4(const IPv4Address& ip) {
    // 224.0.0.0/4
    uint32_t be = htonl(ip.toInt());             // to bytes in network order
    uint8_t first = static_cast<uint8_t>(be >> 24);
    return first >= 224 && first <= 239;
}

static MacAddress multicastMacFromIPv4(const IPv4Address& ip) {
    // RFC 1112 mapping: 01:00:5e:0xxxxxxx:xxxx:xxxx (lower 23 bits of IP)
    uint32_t be = htonl(ip.toInt());
    uint8_t b2 = static_cast<uint8_t>(be >> 16);
    uint8_t b3 = static_cast<uint8_t>(be >> 8);
    uint8_t b4 = static_cast<uint8_t>(be);
    uint8_t macBytes[6] = {0x01, 0x00, 0x5e, static_cast<uint8_t>(b2 & 0x7F), b3, b4};
    return MacAddress(macBytes);
}

static bool same5tuple_unmodified(const Packet& a, const Packet& b) {
    const IPv4Layer* ipA = a.getLayerOfType<IPv4Layer>();
    const IPv4Layer* ipB = b.getLayerOfType<IPv4Layer>();
    const UdpLayer*  uA  = a.getLayerOfType<UdpLayer>();
    const UdpLayer*  uB  = b.getLayerOfType<UdpLayer>();
    if (!ipA || !ipB || !uA || !uB) return false;
    return ipA->getSrcIPv4Address() == ipB->getSrcIPv4Address() &&
           ipA->getDstIPv4Address() == ipB->getDstIPv4Address() &&
           uA->getSrcPort() == uB->getSrcPort() &&
           uA->getDstPort() == uB->getDstPort();
}

// Add an 8-byte TLV IPv4 option holding [ts_next], with padding to 4B alignment.
// If options would exceed 60 bytes, remove existing options once and retry.
static bool add_next_ts_to_ipopts(Packet& pkt, const uint8_t ts_next[8]) {
    IPv4Layer* ip = pkt.getLayerOfType<IPv4Layer>();
    if (!ip) return false;

    size_t curHdr = ip->getHeaderLen(); // includes existing options
    const size_t addLen = 2 + 8;        // type(1) + len(1) + data(8)
    size_t pad = (4 - ((curHdr + addLen) % 4)) % 4;
    if (curHdr + addLen + pad > 60) {
        ip->removeAllOptions();
        curHdr = ip->getHeaderLen();
        pad = (4 - ((curHdr + addLen) % 4)) % 4;
        if (curHdr + addLen + pad > 60) return false;
    }

    uint8_t val[8]; std::memcpy(val, ts_next, 8);
    IPv4OptionBuilder optBuilder(kOurIpv4OptType, val, static_cast<uint8_t>(sizeof(val)));
    if (ip->addOption(optBuilder).isNull()) return false;

    for (size_t i = 0; i < pad; ++i) {
        IPv4OptionBuilder nopBuilder(IPV4OPT_NOP, nullptr, 0);
        if (ip->addOption(nopBuilder).isNull()) return false;
    }
    return true;
}

// Apply IP/UDP/L2 rewrites if configured. Returns true if anything changed.
static bool apply_rewrites(Packet& pkt) {
    bool modified = false;

    if (IPv4Layer* ip = pkt.getLayerOfType<IPv4Layer>()) {
        if (g_haveNewDstGroup) {
            ip->setDstIPv4Address(g_newDstGroup);
            modified = true;
        }
    }

    if (UdpLayer* udp = pkt.getLayerOfType<UdpLayer>()) {
        if (g_newDstPort != 0) {
            // Older PcapPlusPlus may not have setDstPort(); write header directly.
            udp->getUdpHeader()->portDst = htons(g_newDstPort);
            modified = true;
        }
    }

    if (g_rewriteL2 && g_haveNewDstGroup && isMulticastIPv4(g_newDstGroup)) {
        if (EthLayer* eth = pkt.getLayerOfType<EthLayer>()) {
            eth->setDestMac(multicastMacFromIPv4(g_newDstGroup));
            modified = true;
        }
    }

    return modified;
}

// ---------------- Main ----------------
int main(int argc, char** argv) {
    if (argc < 3) {
        std::fprintf(stderr,
            "Usage: %s in.pcap out.pcap [--same-flow] [--send-off N]\n"
            "                 [--rewrite-mgroup A.B.C.D] [--rewrite-dport N] [--rewrite-l2]\n",
            argv[0]);
        return 2;
    }

    const char* inPath  = argv[1];
    const char* outPath = argv[2];

    // Parse CLI
    for (int i = 3; i < argc; ++i) {
        if (std::strcmp(argv[i], "--same-flow") == 0) {
            g_requireSameFlow = true;
        } else if (std::strcmp(argv[i], "--send-off") == 0 && i + 1 < argc) {
            g_spcast_send_off = static_cast<size_t>(std::strtoul(argv[++i], nullptr, 0));
        } else if (std::strcmp(argv[i], "--rewrite-mgroup") == 0 && i + 1 < argc) {
            const char* s = argv[++i];
            in_addr a{};
            if (inet_pton(AF_INET, s, &a) != 1) {
                std::fprintf(stderr, "error: invalid IPv4 for --rewrite-mgroup\n");
                return 2;
            }
            uint32_t hostOrder = ntohl(a.s_addr);
            g_newDstGroup = IPv4Address(hostOrder);
            g_haveNewDstGroup = true;
            if (!isMulticastIPv4(g_newDstGroup)) {
                std::fprintf(stderr, "warning: --rewrite-mgroup is not in 224.0.0.0/4; proceeding anyway\n");
            }
        } else if (std::strcmp(argv[i], "--rewrite-dport") == 0 && i + 1 < argc) {
            unsigned long v = std::strtoul(argv[++i], nullptr, 0);
            if (v == 0 || v > 65535) {
                std::fprintf(stderr, "error: invalid port for --rewrite-dport\n");
                return 2;
            }
            g_newDstPort = static_cast<uint16_t>(v);
        } else if (std::strcmp(argv[i], "--rewrite-l2") == 0) {
            g_rewriteL2 = true;
        } else {
            std::fprintf(stderr, "error: unknown option '%s'\n", argv[i]);
            return 2;
        }
    }

    // Reader (pcap or pcapng)
    IFileReaderDevice* reader = IFileReaderDevice::getReader(inPath);
    if (!reader || !reader->open()) {
        std::fprintf(stderr, "error: cannot open input '%s'\n", inPath);
        return 1;
    }

    // Prime sliding window: read first packet *before* creating the writer,
    // then construct the writer with this packet's link-layer type.
    RawPacket curRaw, nextRaw;
    bool haveCur = reader->getNextPacket(curRaw);
    if (!haveCur) {
        reader->close();
        delete reader;
        return 0;
    }

    // Create writer using the first packet's link-layer type
    LinkLayerType llt = curRaw.getLinkLayerType();
    PcapFileWriterDevice writer(outPath, llt);
    if (!writer.open()) {
        std::fprintf(stderr, "error: cannot open output '%s'\n", outPath);
        reader->close();
        delete reader;
        return 1;
    }

    bool haveNext = reader->getNextPacket(nextRaw);

    uint64_t inCount = 0, outCount = 0, edited = 0;

    while (haveCur) {
        ++inCount;
        Packet curPkt(&curRaw);

        // 1) Timestamp extraction and option injection BEFORE any rewrites
        uint8_t ts_this[8] = {0};
        bool ok_this = extract_spcast_send_ts8(curPkt, ts_this);

        uint8_t ts_next[8] = {0};
        bool ok_next = false;
        if (haveNext) {
            Packet nextPkt(&nextRaw);
            if (!g_requireSameFlow || same5tuple_unmodified(curPkt, nextPkt))
                ok_next = extract_spcast_send_ts8(nextPkt, ts_next);
        }
        if (!haveNext || (g_requireSameFlow && !ok_next)) {
            if (ok_this) { std::memcpy(ts_next, ts_this, 8); ok_next = true; }
        }

        bool modified = false;
        if (ok_this && ok_next) {
            if (add_next_ts_to_ipopts(curPkt, ts_next)) modified = true;
            else std::fprintf(stderr, "warn: packet %llu: could not add IPv4 option (space?)\n", (unsigned long long)inCount);
        }

        // 2) Apply rewrites (IP dst / UDP dport / L2 dest MAC)
        if (apply_rewrites(curPkt)) modified = true;

        // 3) Recompute checksums/lengths if needed
        if (modified) { curPkt.computeCalculateFields(); ++edited; }

        // 4) Write out
        if (!writer.writePacket(*curPkt.getRawPacket()))
            std::fprintf(stderr, "warn: failed to write packet %llu\n", (unsigned long long)inCount);
        else
            ++outCount;

        // Slide window
        if (!haveNext) break;
        curRaw = nextRaw;
        haveCur = true;
        haveNext = reader->getNextPacket(nextRaw);
    }

    reader->close();
    delete reader;
    writer.close();

    std::fprintf(stderr, "Processed %llu packets; wrote %llu; edited %llu.\n",
                 (unsigned long long)inCount,
                 (unsigned long long)outCount,
                 (unsigned long long)edited);
    return 0;
}
