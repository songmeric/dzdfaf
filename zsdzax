// MIT License
//
// File: ipopt_ts_spcast_v3.cpp
//
// PURPOSE:
//   - Read a PCAP/PCAPNG file and walk packets with a 2-packet sliding window.
//   - For UDP packets carrying Spcast V3, extract 8-byte send_timestamp_ns and
//     write ONLY the *next* packet's timestamp into an IPv4 option on the *current* packet.
//   - Optionally rewrite the IPv4 destination multicast group and UDP destination port,
//     and (optionally) rewrite the Ethernet destination MAC to match the new multicast IP.
//   - Recompute all dependent fields (IPv4 total length & checksum, UDP checksum).
//
// BUILD (Linux/macOS):
//   g++ -O2 -std=c++17 ipopt_ts_spcast_v3.cpp \
//       -lPcap++ -lPacket++ -lCommon++ -lpcap -lpthread -o ipopt_ts_spcast_v3
//
// USAGE:
//   ./ipopt_ts_spcast_v3 in.pcap out.pcap [options]
//     --same-flow            Only use next packet if same 5-tuple
//     --send-off N           Offset of send_timestamp_ns in UDP payload (default: 9)
//     --rewrite-mgroup IP    Overwrite IPv4 dst to this (multicast) group for UDP packets
//     --rewrite-dport N      Overwrite UDP dst port for UDP packets
//     --rewrite-l2           Also rewrite Ethernet dst MAC to match the new multicast IP
//
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <arpa/inet.h>

#include "PcapFileDevice.h"
#include "Packet.h"
#include "IPv4Layer.h"
#include "UdpLayer.h"
#include "EthLayer.h"

using namespace pcpp;

// Deduce the IPv4 option enum type in a portable way across PcapPlusPlus versions.
using IPv4OptEnum = decltype(IPV4OPT_NOP);
// Use an experimental/private-use option number (RFC 3692-style). Decimal 30 (0x1E).
static constexpr IPv4OptEnum kOurIpv4OptType = static_cast<IPv4OptEnum>(30);

// ---------------- Configuration ----------------
static IPv4Address g_newDstGroup;             // multicast group to overwrite to
static bool        g_haveNewDstGroup = false;
static uint16_t    g_newDstPort      = 0;     // 0 = no change
static bool        g_rewriteL2       = false; // also rewrite Ethernet dest MAC
static size_t      g_spcast_send_off = 9;     // Spcast V3 send_timestamp_ns offset (ver:1, recv:8, send:8)
static bool        g_requireSameFlow = false;

// ---------------- Spcast V3 extraction ----------------
static constexpr uint8_t SPCAST_V3_VERSION = 3;
static constexpr size_t  MIN_SPCAST_HDR    = 1 + 8 + 8; // ver + recv + send

static bool extract_spcast_send_ts8(Packet& pkt, uint8_t out[8]) {
    UdpLayer* udp = pkt.getLayerOfType<UdpLayer>();
    if (!udp) return false;
    const uint8_t* payload = udp->getLayerPayload();
    size_t payloadLen = udp->getLayerPayloadSize();
    if (!payload || payloadLen < MIN_SPCAST_HDR) return false;
    if (payload[0] != SPCAST_V3_VERSION) return false;
    if (payloadLen < g_spcast_send_off + 8) return false;
    std::memcpy(out, payload + g_spcast_send_off, 8);
    return true;
}

// ---------------- Helpers ----------------
static bool isMulticastIPv4(const IPv4Address& ip) {
    // 224.0.0.0/4
    uint32_t be = htonl(ip.toInt());             // to bytes in network order
    uint8_t first = static_cast<uint8_t>(be >> 24);
    return first >= 224 && first <= 239;
}

static MacAddress multicastMacFromIPv4(const IPv4Address& ip) {
    // RFC 1112 mapping: 01:00:5e:0xxxxxxx:xxxx:xxxx (lower 23 bits of IP)
    uint32_t be = htonl(ip.toInt());
    uint8_t b2 = static_cast<uint8_t>(be >> 16);
    uint8_t b3 = static_cast<uint8_t>(be >> 8);
    uint8_t b4 = static_cast<uint8_t>(be);
    uint8_t macBytes[6] = {0x01, 0x00, 0x5e, static_cast<uint8_t>(b2 & 0x7F), b3, b4};
    return MacAddress(macBytes);
}

static bool same5tuple_unmodified(const Packet& a, const Packet& b) {
    const IPv4Layer* ipA = a.getLayerOfType<IPv4Layer>();
    const IPv4Layer* ipB = b.getLayerOfType<IPv4Layer>();
    const UdpLayer*  uA  = a.getLayerOfType<UdpLayer>();
    const UdpLayer*  uB  = b.getLayerOfType<UdpLayer>();
    if (!ipA || !ipB || !uA || !uB) return false;
    return ipA->getSrcIPv4Address() == ipB->getSrcIPv4Address() &&
           ipA->getDstIPv4Address() == ipB->getDstIPv4Address() &&
           uA->getSrcPort() == uB->getSrcPort() &&
           uA->getDstPort() == uB->getDstPort();
}

// Add an 8-byte TLV IPv4 option holding [ts_next], with padding to 4B alignment.
// If options would exceed 60 bytes, remove existing options once and retry.
static bool add_next_ts_to_ipopts(Packet& pkt, const uint8_t ts_next[8]) {
    IPv4Layer* ip = pkt.getLayerOfType<IPv4Layer>();
    if (!ip) return false;

    size_t curHdr = ip->getHeaderLen(); // includes existing options
    const size_t addLen = 2 + 8;        // type(1) + len(1) + data(8)
    size_t pad = (4 - ((curHdr + addLen) % 4)) % 4;
    if (curHdr + addLen + pad > 60) {
        ip->removeAllOptions();
        curHdr = ip->getHeaderLen();
        pad = (4 - ((curHdr + addLen) % 4)) % 4;
        if (curHdr + addLen + pad > 60) return false;
    }

    uint8_t val[8]; std::memcpy(val, ts_next, 8);
    IPv4OptionBuilder optBuilder(kOurIpv4OptType, val, static_cast<uint8_t>(sizeof(val)));
    if (ip->addOption(optBuilder).isNull()) return false;

    for (size_t i = 0; i < pad; ++i) {
        IPv4OptionBuilder nopBuilder(IPV4OPT_NOP, nullptr, 0);
        if (ip->addOption(nopBuilder).isNull()) return false;
    }
    return true;
}

// Apply IP/UDP/L2 rewrites if configured. Returns true if anything changed.
static bool apply_rewrites(Packet& pkt) {
    bool modified = false;

    if (IPv4Layer* ip = pkt.getLayerOfType<IPv4Layer>()) {
        if (g_haveNewDstGroup) {
            ip->setDstIPv4Address(g_newDstGroup);
            modified = true;
        }
    }

    if (UdpLayer* udp = pkt.getLayerOfType<UdpLayer>()) {
        if (g_newDstPort != 0) {
            // Older PcapPlusPlus may not have setDstPort(); write header directly.
            udp->getUdpHeader()->portDst = htons(g_newDstPort);
            modified = true;
        }
    }

    if (g_rewriteL2 && g_haveNewDstGroup && isMulticastIPv4(g_newDstGroup)) {
        if (EthLayer* eth = pkt.getLayerOfType<EthLayer>()) {
            eth->setDestMac(multicastMacFromIPv4(g_newDstGroup));
            modified = true;
        }
    }

    return modified;
}

// ---------------- Main ----------------
int main(int argc, char** argv) {
    if (argc < 3) {
        std::fprintf(stderr,
            "Usage: %s in.pcap out.pcap [--same-flow] [--send-off N]\n"
            "                 [--rewrite-mgroup A.B.C.D] [--rewrite-dport N] [--rewrite-l2]\n",
            argv[0]);
        return 2;
    }

    const char* inPath  = argv[1];
    const char* outPath = argv[2];

    // Parse CLI
    for (int i = 3; i < argc; ++i) {
        if (std::strcmp(argv[i], "--same-flow") == 0) {
            g_requireSameFlow = true;
        } else if
