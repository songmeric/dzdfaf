#!/usr/bin/env python3
"""
latency-portal  ‚óÜ  nano-latency visualiser

What's new (engineer-friendly, SaaS-style):
- Baseline comparison via CDF overlay (time-series overlay removed)
- Clear delta chips with metric labels (Œî P50, Œî P95, Œî P99, Œî P99.9, Œî Outliers)
- Plain-English interpretation guide with thresholds (configurable below)
- "Stability & tail" rollups with simple wording (no stats jargon)
- Dark mode support via base template
- No extra dependencies
"""

import base64, io, json, logging, pathlib, sqlite3, statistics, datetime as dt
from typing import List, Tuple, Optional, Dict
import pandas as pd
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from fastapi import FastAPI, Request, HTTPException, Form
from fastapi.responses import HTMLResponse, RedirectResponse, PlainTextResponse
from fastapi.templating import Jinja2Templates

CSV_DIR = pathlib.Path("/apps/sp_hfts/latency_csv"); CSV_DIR.mkdir(parents=True, exist_ok=True)
BASE_DIR = pathlib.Path(__file__).parent
LOG_FILE = BASE_DIR / "portal.log"
DB_PATH  = str(CSV_DIR / "runs.db")
TPL_DIR  = BASE_DIR / "templates"

logging.basicConfig(level=logging.INFO,
                    format="%(asctime)s  %(levelname)-8s %(message)s",
                    handlers=[logging.FileHandler(LOG_FILE, encoding="utf-8"),
                              logging.StreamHandler()])
log = logging.getLogger("latency-portal")

app       = FastAPI(title="Latency-Portal")
templates = Jinja2Templates(directory=str(TPL_DIR))

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Interpretation thresholds (edit to fit your org)
# unit: "pct" = percent change vs baseline; "pp" = percentage points
INTERPRETATION_RULES = {
    "p50":  {"warn": 10.0, "fail": 20.0, "unit": "pct", "label": "P50"},
    "p95":  {"warn": 7.0,  "fail": 15.0, "unit": "pct", "label": "P95"},
    "p99":  {"warn": 5.0,  "fail": 10.0, "unit": "pct", "label": "P99"},
    "p999": {"warn": 3.0,  "fail": 6.0,  "unit": "pct", "label": "P99.9"},
    # outlier_rate is measured as share ‚àà [0,1], so deltas are in percentage points
    "outlier_rate": {"warn": 0.5, "fail": 1.0, "unit": "pp", "label": "Outlier rate"},
}
# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

def _init_db() -> None:
    with sqlite3.connect(DB_PATH) as c:
        c.execute("""CREATE TABLE IF NOT EXISTS runs(
            id          TEXT PRIMARY KEY,
            filename    TEXT,
            created_at  TEXT,
            p50         REAL, p95 REAL, p99 REAL,
            stdev       REAL, count INTEGER,
            approved    INTEGER DEFAULT 0,
            approved_by TEXT, approved_at TEXT,
            png_b64     TEXT );""")
_init_db()

def _row_to_dict(row) -> dict:
    keys=("id","filename","created_at","p50","p95","p99","stdev","count",
          "approved","approved_by","approved_at","png_b64")
    return dict(zip(keys,row))

# ‚îÄ‚îÄ‚îÄ CSV ingestion (unchanged) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _ingest_new_files() -> None:
    with sqlite3.connect(DB_PATH) as c:
        known = {r[0] for r in c.execute("SELECT id FROM runs")}
    for csv_path in CSV_DIR.glob("*.csv"):
        run_id = csv_path.stem
        if run_id in known: continue
        try:
            df = pd.read_csv(csv_path, skipinitialspace=True,
                    names=["entry_id","ingress","egress","latency_ns"],
                    header=0, dtype={"ingress":"int64","latency_ns":"int64"},
                    engine="python")
        except Exception as exc:
            log.error("Failed to parse %s: %s", csv_path.name, exc); continue
        if df.empty: log.error("Empty CSV %s", csv_path.name); continue
        df.sort_values("ingress", inplace=True)
        lat = df["latency_ns"]
        p50,p95,p99 = (lat.quantile(q) for q in (0.5,0.95,0.99))
        stdev = statistics.pstdev(lat)
        fig, ax = plt.subplots(); ax.plot(df["ingress"], lat, linewidth=0.5)
        ax.set_xlabel("Ingress ns"); ax.set_ylabel("Latency ns"); ax.set_title(run_id)
        buf = io.BytesIO(); fig.savefig(buf, format="png", dpi=110, bbox_inches="tight")
        plt.close(fig); png_b64 = base64.b64encode(buf.getvalue()).decode()
        with sqlite3.connect(DB_PATH) as c:
            c.execute("INSERT INTO runs VALUES (?,?,?,?,?,?,?,?,?,?,?,?)",
                      (run_id, csv_path.name, dt.datetime.utcnow().isoformat(),
                       p50,p95,p99,stdev,len(lat),0,None,None,png_b64))
        log.info("Ingested %s", csv_path.name)

@app.middleware("http")
async def auto_ingest(request: Request, call_next):
    _ingest_new_files(); return await call_next(request)

# ‚îÄ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def _per_second_quantiles(df) -> Tuple[List[str], List[float], List[float], List[float]]:
    df["sec"] = (df["ingress"] // 1_000_000_000)
    grouped   = df.groupby("sec")["latency_ns"]
    p50 = grouped.quantile(0.50); p95 = grouped.quantile(0.95); p99 = grouped.quantile(0.99)
    idx_iso = pd.to_datetime(p50.index.astype("int64"), unit="s", utc=True)\
                 .strftime("%Y-%m-%dT%H:%M:%SZ").tolist()
    return idx_iso, p50.tolist(), p95.tolist(), p99.tolist()

def _load_run_meta(run_id: str) -> dict:
    with sqlite3.connect(DB_PATH) as c:
        row = c.execute("SELECT * FROM runs WHERE id=?", (run_id,)).fetchone()
    if not row:
        raise HTTPException(404, "run not found")
    return _row_to_dict(row)

def _load_run_df_by_meta(meta: dict) -> pd.DataFrame:
    csv_path = CSV_DIR / meta["filename"]
    if not csv_path.exists():
        raise HTTPException(500, "CSV missing")
    df = pd.read_csv(csv_path, skipinitialspace=True,
        names=["entry_id","ingress","egress","latency_ns"], header=0,
        dtype={"ingress":"int64","latency_ns":"int64"}, engine="python"
    ).sort_values("ingress")
    return df

def _summary_stats(lat: pd.Series) -> Dict[str, float]:
    lat = pd.to_numeric(lat, errors="coerce").dropna()
    if lat.empty:
        return {}
    q = lat.quantile([0.5, 0.95, 0.99, 0.999])
    median = float(q.loc[0.5])
    mad = float((lat - median).abs().median())
    madn = float(1.4826 * mad) if mad > 0 else 0.0   # robust œÉ
    iqr  = float(lat.quantile(0.75) - lat.quantile(0.25))
    mean = float(lat.mean())
    stdev = float(statistics.pstdev(lat))
    denom = madn if madn > 0 else 1.0
    robust_z = ((lat - median).abs() / denom)
    outlier_rate = float((robust_z > 3.5).mean())
    return {
        "p50": float(q.loc[0.5]),
        "p95": float(q.loc[0.95]),
        "p99": float(q.loc[0.99]),
        "p999": float(q.loc[0.999]),
        "mean": mean,
        "stdev": stdev,
        "madn": madn,
        "iqr": iqr,
        "min": float(lat.min()),
        "max": float(lat.max()),
        "count": int(lat.size),
        "outlier_rate": outlier_rate,
    }

def _find_default_baseline_id(current_id: str) -> Optional[str]:
    with sqlite3.connect(DB_PATH) as c:
        row = c.execute("SELECT created_at FROM runs WHERE id=?", (current_id,)).fetchone()
        if not row:
            return None
        created_at = row[0]
        r = c.execute("""SELECT id FROM runs
                         WHERE approved=1 AND created_at < ?
                         ORDER BY created_at DESC LIMIT 1""", (created_at,)).fetchone()
        if r:
            return r[0]
        r = c.execute("""SELECT id FROM runs
                         WHERE created_at < ?
                         ORDER BY created_at DESC LIMIT 1""", (created_at,)).fetchone()
        return r[0] if r else None

def _baseline_candidates(current_created_at: str, limit:int=100) -> List[dict]:
    with sqlite3.connect(DB_PATH) as c:
        rows = c.execute(
            """SELECT id,created_at,approved,p50,p95,p99,stdev,count
               FROM runs
               WHERE created_at < ?
               ORDER BY created_at DESC
               LIMIT ?""",
            (current_created_at, int(limit))
        ).fetchall()
    keys=("id","created_at","approved","p50","p95","p99","stdev","count")
    return [dict(zip(keys,r)) for r in rows]

# ‚îÄ‚îÄ‚îÄ Routes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@app.get("/", response_class=HTMLResponse)
def list_runs(request: Request):
    with sqlite3.connect(DB_PATH) as c:
        rows=c.execute("SELECT * FROM runs ORDER BY created_at DESC").fetchall()
    return templates.TemplateResponse("list.html", {"request":request,"runs":[_row_to_dict(r) for r in rows]})

@app.get("/approved", response_class=HTMLResponse)
def approved(request: Request):
    with sqlite3.connect(DB_PATH) as c:
        rows=c.execute("SELECT * FROM runs WHERE approved=1 ORDER BY created_at DESC").fetchall()
    return templates.TemplateResponse("list.html", {"request":request,"runs":[_row_to_dict(r) for r in rows]})

@app.get("/runs/latest")
def latest_redirect():
    with sqlite3.connect(DB_PATH) as c:
        row=c.execute("SELECT id FROM runs ORDER BY created_at DESC LIMIT 1").fetchone()
    if not row: raise HTTPException(404,"No runs")
    return RedirectResponse(f"/runs/{row[0]}", status_code=303)

@app.get("/runs/{run_id}", response_class=HTMLResponse)
def show_run(request: Request, run_id:str):
    with sqlite3.connect(DB_PATH) as c:
        row=c.execute("SELECT * FROM runs WHERE id=?", (run_id,)).fetchone()
    if not row: raise HTTPException(404)
    d=_row_to_dict(row)

    # Load CSV
    csv_path=CSV_DIR/d["filename"]
    if not csv_path.exists(): raise HTTPException(500,"CSV missing")
    df=pd.read_csv(csv_path, skipinitialspace=True,
        names=["entry_id","ingress","egress","latency_ns"], header=0,
        dtype={"ingress":"int64","latency_ns":"int64"}, engine="python").sort_values("ingress")
    df["ingress_dt"]=pd.to_datetime(df["ingress"], unit="ns", utc=True)

    # Raw plot data (current only)
    x_json=json.dumps(df["ingress_dt"].dt.strftime("%Y-%m-%dT%H:%M:%S.%fZ").tolist())
    y_json=json.dumps(df["latency_ns"].tolist())

    # Per-second quantiles (current only)
    sec_iso,p50s,p95s,p99s=_per_second_quantiles(df)

    # Rollups for current run
    stats = _summary_stats(df["latency_ns"])

    # CDF (no extra deps)
    points = 300
    ps = [(i+1)/(points+1) for i in range(points)]
    qs = df["latency_ns"].quantile(ps).astype(float).tolist()

    # Baseline options & auto-select
    baseline_default = _find_default_baseline_id(run_id) or ""
    baseline_runs    = _baseline_candidates(d["created_at"], limit=100)

    return templates.TemplateResponse("detail.html",
        {"request":request, **d,
         "x_json":x_json, "y_json":y_json,
         "sec_json":json.dumps(sec_iso),
         "p50_json":json.dumps(p50s),
         "p95_json":json.dumps(p95s),
         "p99_json":json.dumps(p99s),
         "baseline_default": baseline_default,
         "baseline_runs": baseline_runs,
         "stats_json": json.dumps(stats),
         "cdf_p_json": json.dumps(ps),
         "cdf_q_json": json.dumps(qs),
         "rules_json": json.dumps(INTERPRETATION_RULES)})

@app.post("/runs/{run_id}/approve")
def approve(run_id:str, user:str=Form("anon")):
    now=dt.datetime.utcnow().isoformat()
    with sqlite3.connect(DB_PATH) as c:
        changed=c.execute("UPDATE runs SET approved=1,approved_by=?,approved_at=? WHERE id=? AND approved=0",
                          (user,now,run_id)).rowcount
    if changed==0: raise HTTPException(409,"already approved or missing")
    return RedirectResponse(f"/runs/{run_id}", status_code=303)

@app.post("/runs/{run_id}/unapprove")
def unapprove(run_id:str):
    with sqlite3.connect(DB_PATH) as c:
        changed=c.execute("UPDATE runs SET approved=0,approved_by=NULL,approved_at=NULL WHERE id=? AND approved=1",
                          (run_id,)).rowcount
    if changed==0: raise HTTPException(409,"not approved or missing")
    return RedirectResponse(f"/runs/{run_id}", status_code=303)

@app.get("/runs/{run_id}/status")
def status(run_id:str):
    with sqlite3.connect(DB_PATH) as c:
        row=c.execute("SELECT approved FROM runs WHERE id=?", (run_id,)).fetchone()
    if not row: raise HTTPException(404)
    return {"run_id":run_id,"approved":bool(row[0])}

@app.get("/logs", response_class=PlainTextResponse)
def view_logs(lines:int=1000):
    try:
        with open(LOG_FILE,"r",encoding="utf-8") as f:
            return PlainTextResponse("".join(f.readlines()[-lines:]))
    except FileNotFoundError: raise HTTPException(404,"log missing")

# ‚îÄ‚îÄ‚îÄ Lightweight JSON for overlays/compare ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
@app.get("/runs/{run_id}/cdf_json")
def cdf_json(run_id:str, points:int=300):
    points = max(50, min(int(points), 2000))
    meta = _load_run_meta(run_id)
    df   = _load_run_df_by_meta(meta)
    lat  = pd.to_numeric(df["latency_ns"], errors="coerce").dropna()
    if lat.empty:
        return {"run_id":run_id,"p":[],"q_ns":[]}
    ps   = [(i+1)/(points+1) for i in range(points)]
    qs   = lat.quantile(ps).astype(float).tolist()
    return {"run_id":run_id,"p":ps,"q_ns":qs}

@app.get("/runs/{run_id}/compare")
def compare_runs(run_id:str, baseline_id:str):
    base_meta = _load_run_meta(baseline_id)
    cur_meta  = _load_run_meta(run_id)
    base_df   = _load_run_df_by_meta(base_meta)
    cur_df    = _load_run_df_by_meta(cur_meta)
    base = _summary_stats(base_df["latency_ns"])
    cur  = _summary_stats(cur_df["latency_ns"])

    def diff(a:float,b:float):
        if b == 0:
            return {"abs": a-b, "pct": None}
        return {"abs": a-b, "pct": (a-b)/b*100.0}

    metrics = ["p50","p95","p99","p999","stdev","madn","iqr","mean","outlier_rate","count"]
    delta = {m: diff(cur.get(m,0.0), base.get(m,0.0)) for m in metrics}
    return {"run_id":run_id, "baseline_id":baseline_id,
            "current":cur, "baseline":base, "delta":delta}





base.html


<!DOCTYPE html>
<html data-bs-theme="light">
<head>
  <meta charset="utf-8">
  <title>{% block title %}Latency Portal{% endblock %}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Bootstrap & DataTables -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.datatables.net/1.13.6/css/dataTables.bootstrap5.min.css" rel="stylesheet">
  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <!-- jQuery + DataTables -->
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.6/js/dataTables.bootstrap5.min.js"></script>
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <style>
    body { font-feature-settings: "ss01" on, "cv01" on; }
    .navbar-brand { font-weight: 600; letter-spacing: .2px; }
    .content-wrap { padding: 1.25rem 0 2rem; }
  </style>
  <script>
    // Theme handling (light/dark) with localStorage, and notify pages to restyle charts
    (function(){
      const KEY = 'lp-theme';
      const html = document.documentElement;
      function apply(theme){
        const t = theme === 'dark' ? 'dark' : 'light';
        html.setAttribute('data-bs-theme', t);
        localStorage.setItem(KEY, t);
        document.dispatchEvent(new CustomEvent('theme-changed', {detail:{theme:t}}));
      }
      function init(){
        const saved = localStorage.getItem(KEY);
        if (saved) apply(saved);
        else {
          // Prefer system
          const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
          apply(prefersDark ? 'dark' : 'light');
        }
        const btn = document.getElementById('themeToggle');
        if (btn) btn.addEventListener('click', ()=> {
          apply(html.getAttribute('data-bs-theme') === 'dark' ? 'light' : 'dark');
        });
      }
      document.addEventListener('DOMContentLoaded', init);
    })();
    // Enable tooltips site-wide
    document.addEventListener('DOMContentLoaded', ()=> {
      [...document.querySelectorAll('[data-bs-toggle="tooltip"]')]
        .forEach(el=>new bootstrap.Tooltip(el));
    });
  </script>
</head>
<body>
  <nav class="navbar navbar-expand-lg bg-body-tertiary border-bottom sticky-top">
    <div class="container-fluid">
      <a class="navbar-brand" href="/">Latency Portal</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#topnav">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div id="topnav" class="collapse navbar-collapse">
        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
          <li class="nav-item"><a class="nav-link" href="/">All runs</a></li>
          <li class="nav-item"><a class="nav-link" href="/approved">Approved</a></li>
          <li class="nav-item"><a class="nav-link" href="/runs/latest">Latest</a></li>
          <li class="nav-item"><a class="nav-link" href="/logs">Logs</a></li>
        </ul>
        <div class="d-flex align-items-center gap-2">
          <button id="themeToggle" class="btn btn-outline-secondary btn-sm" type="button" title="Toggle theme" data-bs-toggle="tooltip">üåô/‚òÄÔ∏è</button>
        </div>
      </div>
    </div>
  </nav>

  <main class="container content-wrap">
    {% block content %}{% endblock %}
  </main>
</body>
</html>




list.html

{% extends 'base.html' %}{% block title %}Latency Benchmarks{% endblock %}
{% block content %}
<div class="d-flex justify-content-between align-items-end mb-3">
  <div>
    <h4 class="mb-1">Latency Benchmarks</h4>
    <div class="text-muted small">Drop CSVs into <code>/apps/sp_hfts/latency_csv/</code>. Each CSV becomes one run.</div>
  </div>
</div>

<table id="runs-table" class="table table-sm table-hover align-middle">
  <thead class="table-light">
    <tr>
      <th>Run</th>
      <th>UTC</th>
      <th title="50th percentile">P50 (ns)</th>
      <th title="95th percentile">P95 (ns)</th>
      <th title="99th percentile">P99 (ns)</th>
      <th title="Population standard deviation">œÉ (ns)</th>
      <th title="Total samples">n</th>
      <th>Status</th>
    </tr>
  </thead>
  <tbody>
  {% for r in runs %}
    <tr>
      <td><a href="/runs/{{ r.id }}" class="text-decoration-none">{{ r.id }}</a></td>
      <td class="text-nowrap">{{ r.created_at[:19] }}</td>
      <td>{{ '%.0f'|format(r.p50) }}</td>
      <td>{{ '%.0f'|format(r.p95) }}</td>
      <td>{{ '%.0f'|format(r.p99) }}</td>
      <td>{{ '%.0f'|format(r.stdev) }}</td>
      <td>{{ r.count }}</td>
      <td>
        {% if r.approved %}
          <span class="badge text-bg-success">APPROVED</span>
        {% else %}
          <span class="badge text-bg-danger">PENDING</span>
        {% endif %}
      </td>
    </tr>
  {% endfor %}
  </tbody>
</table>

<script>
  $(function(){
    $('#runs-table').DataTable({
      order: [[1,'desc']],
      pageLength: 25,
      lengthMenu: [10,25,50,100],
      stateSave: true
    });
  });
</script>
{% endblock %}



detail.html

{% extends 'base.html' %}{% block title %}Run {{ id }}{% endblock %}
{% block content %}
<style>
  .pill { display:inline-flex; align-items:center; gap:.35rem; padding:.25rem .5rem; border-radius:999px; background:var(--bs-tertiary-bg); border:1px solid var(--bs-border-color); font-size:.85rem; }
  .pill .label { color:var(--bs-secondary-color); }
  .pill .value { font-weight:600; }
  .metric-row { display:flex; flex-wrap:wrap; gap:.5rem .75rem; }

  .delta-chip { padding:.25rem .5rem; border-radius:.5rem; font-weight:600; display:inline-flex; gap:.35rem; align-items:center; }
  .delta-up   { color:#842029; background:#f8d7da; }   /* regression */
  .delta-down { color:#0f5132; background:#d1e7dd; }   /* improvement */
  .delta-watch { color:#664d03; background:#fff3cd; }  /* watch */
  .delta-unknown { color:var(--bs-secondary-color); background:var(--bs-tertiary-bg); }

  .card-clean { border:1px solid var(--bs-border-color); border-radius:.5rem; }
  .card-clean .card-header { background:transparent; border-bottom:1px solid var(--bs-border-color); }
</style>

<div class="d-flex justify-content-between align-items-start mb-3">
  <div>
    <h4 class="mb-1">Run {{ id }}</h4>
    <div class="text-muted small">{{ created_at[:19] }} UTC
      {% if approved %}¬∑ <span class="text-success">APPROVED</span>
      {% else %}¬∑ <span class="text-danger">PENDING</span>{% endif %}
    </div>
    <!-- Key metrics (original set) -->
    <div class="metric-row mt-2">
      <span class="pill" data-bs-toggle="tooltip" title="50% of latencies are below this value (median)">
        <span class="label">P50</span><span class="value">{{ '%.0f'|format(p50) }} ns</span>
      </span>
      <span class="pill" data-bs-toggle="tooltip" title="95th percentile latency">
        <span class="label">P95</span><span class="value">{{ '%.0f'|format(p95) }} ns</span>
      </span>
      <span class="pill" data-bs-toggle="tooltip" title="99th percentile latency">
        <span class="label">P99</span><span class="value">{{ '%.0f'|format(p99) }} ns</span>
      </span>
      <span class="pill" data-bs-toggle="tooltip" title="Population standard deviation (jitter)">
        <span class="label">œÉ</span><span class="value">{{ '%.0f'|format(stdev) }} ns</span>
      </span>
      <span class="pill" data-bs-toggle="tooltip" title="Total samples">
        <span class="label">n</span><span class="value">{{ count }}</span>
      </span>
    </div>
  </div>

  <!-- Baseline selector -->
  <div>
    <label class="form-label mb-1">Baseline</label>
    <select id="baselineSelect" class="form-select form-select-sm" style="min-width: 300px;">
      <option value="" {% if not baseline_default %}selected{% endif %}>‚Äî none ‚Äî</option>
      {% for r in baseline_runs %}
        <option value="{{ r.id }}" {% if baseline_default and r.id == baseline_default %}selected{% endif %}>
          {{ r.id }} ¬∑ {{ r.created_at[:19] }} UTC{% if r.approved %} ‚úì{% endif %}
        </option>
      {% endfor %}
    </select>
    <div class="form-text">Used for CDF overlay and deltas.</div>
  </div>
</div>

<!-- Compact, labeled delta summary -->
<div id="delta-summary" class="row g-2 mb-3" style="display:none;">
  <div class="col-12 col-md-auto"><span class="text-muted">Œî vs baseline:</span></div>
  <div class="col-auto"><span class="delta-chip" id="d-p50">Œî P50</span></div>
  <div class="col-auto"><span class="delta-chip" id="d-p95">Œî P95</span></div>
  <div class="col-auto"><span class="delta-chip" id="d-p99">Œî P99</span></div>
  <div class="col-auto"><span class="delta-chip" id="d-p999">Œî P99.9</span></div>
  <div class="col-auto"><span class="delta-chip" id="d-or">Œî Outliers</span></div>
</div>

<!-- Tabs -->
<ul class="nav nav-tabs" id="viewTabs" role="tablist">
  <li class="nav-item" role="presentation">
    <button class="nav-link active" id="tab-cdf" data-bs-toggle="tab" data-bs-target="#pane-cdf" type="button" role="tab">Distribution (CDF)</button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="tab-quant" data-bs-toggle="tab" data-bs-target="#pane-quant" type="button" role="tab">Per‚Äësecond Quantiles</button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="tab-raw" data-bs-toggle="tab" data-bs-target="#pane-raw" type="button" role="tab">Raw Messages</button>
  </li>
</ul>

<div class="tab-content">
  <div class="tab-pane fade show active" id="pane-cdf" role="tabpanel" aria-labelledby="tab-cdf">
    <div id="cdfplot" style="height:380px;"></div>
    <div class="form-check mt-2">
      <input class="form-check-input" type="checkbox" id="toggleBaselineCDF" checked>
      <label class="form-check-label" for="toggleBaselineCDF">Overlay baseline on CDF</label>
    </div>
  </div>
  <div class="tab-pane fade" id="pane-quant" role="tabpanel" aria-labelledby="tab-quant">
    <div id="quantplot" style="height:360px;"></div>
    <div class="form-text">Current run only ‚Äî use CDF for baseline comparison.</div>
  </div>
  <div class="tab-pane fade" id="pane-raw" role="tabpanel" aria-labelledby="tab-raw">
    <div id="rawplot" style="height:360px;"></div>
    <div class="form-text">Dense time series for shape only; not used for approval.</div>
  </div>
</div>

<!-- Stability & tail indicators (plain-English) -->
<div class="card card-clean mt-4">
  <div class="card-header"><strong>Stability & tail indicators</strong></div>
  <div class="card-body">
    <div class="row row-cols-2 row-cols-md-3 row-cols-lg-4 g-3" id="current-stats"></div>
    <details class="mt-2">
      <summary class="small text-muted">How to read these</summary>
      <ul class="small mb-0">
        <li><b>Ultra tail (P99.9)</b>: extreme latency; improvements here protect worst‚Äëcase behaviour.</li>
        <li><b>Jitter (robust)</b>: variability insensitive to outliers (MAD-based). Lower = steadier.</li>
        <li><b>Spread (IQR)</b>: middle 50% band width. Lower = tighter bulk.</li>
        <li><b>Outliers (%)</b>: share of samples flagged by a robust rule; lower is better.</li>
      </ul>
    </details>
  </div>
</div>

<!-- Interpretation guide -->
<div class="card card-clean mt-4">
  <div class="card-header"><strong>Interpretation guide (default thresholds)</strong></div>
  <div class="card-body">
    <div class="row row-cols-1 row-cols-lg-2 g-3">
      <div>
        <table class="table table-sm">
          <thead class="table-light">
            <tr><th>Metric</th><th>Warn if</th><th>Fail if</th></tr>
          </thead>
          <tbody id="guide-table"></tbody>
        </table>
      </div>
      <div class="small text-muted">
        <p class="mb-2">Use the CDF overlay to verify distribution shifts. Tail metrics (P99/P99.9) matter more than P50 in production risk.</p>
        <ul class="mb-0">
          <li><b>P50</b>: UX/snappiness. OK to trade small regressions for big tail wins.</li>
          <li><b>P95/P99</b>: latency under load. Keep regressions here limited.</li>
          <li><b>P99.9</b>: worst‚Äëcase protection. Prioritize improvements here.</li>
          <li><b>Outliers</b>: noisy tails; rising rate signals instability or intermittent issues.</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<!-- Approval actions -->
{% if approved %}
  <div class="alert alert-success mt-4 d-flex justify-content-between align-items-center">
    <span>Approved by <b>{{ approved_by }}</b> at {{ approved_at[:19] }} UTC</span>
    <form action="/runs/{{ id }}/unapprove" method="post">
      <button class="btn btn-outline-danger btn-sm" data-bs-toggle="tooltip" title="Mark this run as not approved">Un‚Äëapprove</button>
    </form>
  </div>
{% else %}
  <form class="mt-4" action="/runs/{{ id }}/approve" method="post">
    <div class="input-group w-auto">
      <input class="form-control form-control-sm" name="user" placeholder="Your name">
      <button class="btn btn-success btn-sm">Approve</button>
    </div>
  </form>
{% endif %}

<script>
  // ---------- Utils
  const RULES = {{ rules_json|safe }};
  const fmtInt = (v)=> (v===null||v===undefined) ? '‚Äì' : Math.round(v).toLocaleString('en');
  const fmtNs  = (v)=> (v===null||v===undefined) ? '‚Äì' : Math.round(v).toLocaleString('en') + ' ns';
  const fmtPct = (v)=> (v===null||v===undefined) ? '‚Äì' : v.toFixed(2) + ' %';

  function makeLayout(title, xTitle, yTitle){
    const cs = getComputedStyle(document.body);
    const color = cs.color || '#212529';
    return {
      title, paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
      font:{color},
      margin:{l:40,r:20,t:40,b:40},
      xaxis:{title:xTitle, type:'date'},
      yaxis:{title:yTitle}
    };
  }
  function makeLayoutXY(title, xTitle, yTitle){
    const cs = getComputedStyle(document.body);
    const color = cs.color || '#212529';
    return {
      title, paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
      font:{color},
      margin:{l:40,r:20,t:40,b:40},
      xaxis:{title:xTitle},
      yaxis:{title:yTitle}
    };
  }

  // ---------- Current-run indicators (plain names)
  (function renderCurrentStats(){
    const s = {{ stats_json|safe }};
    const items = [
      {k:'p999',lbl:'Ultra tail (P99.9)',fmt:fmtNs, tip:'Extreme latency (99.9th)'},
      {k:'madn',lbl:'Jitter (robust)',  fmt:fmtNs, tip:'MAD-based variability'},
      {k:'iqr', lbl:'Spread (IQR)',     fmt:fmtNs, tip:'Middle 50% width'},
      {k:'outlier_rate',lbl:'Outliers (%)',fmt:(v)=>fmtPct(v*100), tip:'Robust outlier share'},
      {k:'mean',lbl:'Mean',fmt:fmtNs, tip:'Arithmetic mean'},
      {k:'stdev',lbl:'œÉ',fmt:fmtNs, tip:'Population standard deviation'},
      {k:'min',lbl:'Min',fmt:fmtNs, tip:'Minimum latency'},
      {k:'max',lbl:'Max',fmt:fmtNs, tip:'Maximum latency'},
    ];
    const box = document.getElementById('current-stats');
    items.forEach(it=>{
      const v = s[it.k]; const val = it.fmt(v);
      const div = document.createElement('div');
      div.innerHTML = `
        <div class="border rounded p-2 h-100" data-bs-toggle="tooltip" title="${it.tip}">
          <div class="text-muted small">${it.lbl}</div>
          <div class="fw-semibold">${val}</div>
        </div>`;
      box.appendChild(div);
    });
    if (window.bootstrap){
      [...document.querySelectorAll('[data-bs-toggle="tooltip"]')]
        .forEach(el=>new bootstrap.Tooltip(el));
    }
  })();

  // ---------- Interpretation guide table
  (function renderGuide(){
    const tbody = document.getElementById('guide-table');
    const rows = [
      ['p50',  'P50'], ['p95','P95'], ['p99','P99'], ['p999','P99.9'], ['outlier_rate','Outlier rate']
    ];
    rows.forEach(([k,label])=>{
      const r = RULES[k];
      const warn = r.unit==='pp' ? `${r.warn} pp` : `${r.warn}%`;
      const fail = r.unit==='pp' ? `${r.fail} pp` : `${r.fail}%`;
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${label}</td><td>+${warn}</td><td>+${fail}</td>`;
      tbody.appendChild(tr);
    });
  })();

  // ---------- CDF (current + optional baseline overlay)
  const CURRENT_CDF = { p: {{ cdf_p_json|safe }}, q_ns: {{ cdf_q_json|safe }}, run_id: "{{ id }}" };
  let baselineCDF = null;

  function renderCDF(){
    const showBaseline = document.getElementById('toggleBaselineCDF').checked;
    const data = [{
      x: CURRENT_CDF.q_ns, y: CURRENT_CDF.p.map(p=>p*100),
      name: `${CURRENT_CDF.run_id}`, mode:'lines'
    }];
    if (baselineCDF && showBaseline){
      data.push({
        x: baselineCDF.q_ns, y: baselineCDF.p.map(p=>p*100),
        name: `${baselineCDF.run_id} (baseline)`, mode:'lines', line:{dash:'dot'}
      });
    }
    Plotly.react('cdfplot', data, makeLayoutXY('Latency distribution (CDF)','Latency (ns)','Cumulative (%)'));
  }

  document.getElementById('toggleBaselineCDF').addEventListener('change', renderCDF);
  document.addEventListener('theme-changed', ()=> {
    // update plot font colors on theme switch
    Plotly.relayout('cdfplot', makeLayoutXY('Latency distribution (CDF)','Latency (ns)','Cumulative (%)'));
    if (quantReady) Plotly.relayout('quantplot', makeLayout('Per-second quantiles (current)','Time (1-s buckets)','Latency (ns)'));
    if (rawReady)   Plotly.relayout('rawplot', makeLayout('Latency per message (current)','Ingress time','Latency (ns)'));
  });

  // ---------- Quantiles & Raw (render on first tab show for sizing)
  let quantReady=false, rawReady=false;
  document.getElementById('viewTabs').addEventListener('shown.bs.tab', (e)=>{
    const id = e.target.getAttribute('data-bs-target');
    if (id === '#pane-quant' && !quantReady){
      Plotly.newPlot('quantplot', [
        {x:{{ sec_json|safe }}, y:{{ p50_json|safe }}, name:'P50', mode:'lines'},
        {x:{{ sec_json|safe }}, y:{{ p95_json|safe }}, name:'P95', mode:'lines'},
        {x:{{ sec_json|safe }}, y:{{ p99_json|safe }}, name:'P99', mode:'lines'}
      ], makeLayout('Per-second quantiles (current)','Time (1-s buckets)','Latency (ns)'));
      quantReady=true;
    }
    if (id === '#pane-raw' && !rawReady){
      Plotly.newPlot('rawplot', [{x:{{ x_json|safe }}, y:{{ y_json|safe }}, mode:'lines', line:{width:1}}],
        makeLayout('Latency per message (current)','Ingress time','Latency (ns)'));
      rawReady=true;
    }
  });

  // ---------- Baseline selection: overlay CDF + labeled delta chips
  function chip(el, text, cls){ el.textContent = text; el.className = `delta-chip ${cls}`; }

  function severityFor(metricKey, delta){
    const r = RULES[metricKey]; if (!r) return {level:'unknown', value:null};
    if (metricKey === 'outlier_rate'){
      // use absolute delta in percentage points
      const val = Math.abs((delta && delta.abs!=null) ? delta.abs*100 : NaN);
      if (isNaN(val)) return {level:'unknown', value:null};
      if (val >= r.fail) return {level:'fail', value:val};
      if (val >= r.warn) return {level:'watch', value:val};
      return {level:'ok', value:val};
    } else {
      const val = Math.abs((delta && delta.pct!=null) ? delta.pct : NaN);
      if (isNaN(val)) return {level:'unknown', value:null};
      if (val >= r.fail) return {level:'fail', value:val};
      if (val >= r.warn) return {level:'watch', value:val};
      return {level:'ok', value:val};
    }
  }

  function paintDelta(elId, metricKey, delta, unitLabel){
    const el = document.getElementById(elId);
    if (!delta){ chip(el, `${RULES[metricKey].label}: n/a`, 'delta-unknown'); return; }
    const lowerIsBetter = new Set(['p50','p95','p99','p999','outlier_rate']);
    const regression = lowerIsBetter.has(metricKey) ? (delta.abs>0) : (delta.abs<0);
    // Build text: Œî X: +123 ns (+4.2%) [OK/Watch/Fail]
    const pctText = (delta.pct==null || isNaN(delta.pct)) ? '' : ` (${delta.pct.toFixed(2)}%)`;
    const absVal = metricKey==='outlier_rate' ? (delta.abs*100).toFixed(2) + ' pp' : Math.round(delta.abs) + ' ns';
    const sev = severityFor(metricKey, delta);
    // Improvements are always OK
    const level = regression ? sev.level : 'ok';
    const clsMap = {ok:'delta-down', watch:'delta-watch', fail:'delta-up', unknown:'delta-unknown'};
    const statusLabel = {ok:'OK', watch:'WATCH', fail:'FAIL', unknown:'N/A'}[level];
    chip(el, `Œî ${RULES[metricKey].label}: ${absVal}${pctText} ‚Ä¢ ${statusLabel}`, clsMap[level]);
  }

  async function updateComparison(baselineId){
    const summary = document.getElementById('delta-summary');
    if (!baselineId){
      baselineCDF = null; renderCDF(); summary.style.display='none';
      return;
    }
    baselineCDF = await (await fetch(`/runs/${baselineId}/cdf_json?points=300`)).json();
    renderCDF();

    const cmp = await (await fetch(`/runs/{{ id }}/compare?baseline_id=${baselineId}`)).json();
    summary.style.display='flex';

    paintDelta('d-p50',  'p50',  cmp.delta.p50,  'ns');
    paintDelta('d-p95',  'p95',  cmp.delta.p95,  'ns');
    paintDelta('d-p99',  'p99',  cmp.delta.p99,  'ns');
    paintDelta('d-p999', 'p999', cmp.delta.p999, 'ns');
    paintDelta('d-or',   'outlier_rate', cmp.delta.outlier_rate, '%');
  }

  const sel = document.getElementById('baselineSelect');
  sel.addEventListener('change', (e)=> updateComparison(e.target.value));

  // Auto-load default baseline if present
  {% if baseline_default %}
    updateComparison("{{ baseline_default }}");
  {% else %}
    renderCDF();
  {% endif %}
</script>
{% endblock %}



