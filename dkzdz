#!/usr/bin/env python3
"""
latency-portal  ◆  nano-latency visualiser
• Adds: baseline comparison (server-rendered dropdown & auto-select), CDF overlay,
        concise delta summary, robust stats (p99.9, MADn, IQR, outlier rate).
• No NumPy dependency.
"""

import base64, io, json, logging, pathlib, sqlite3, statistics, datetime as dt
from typing import List, Tuple, Optional, Dict
import pandas as pd
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt
from fastapi import FastAPI, Request, HTTPException, Form
from fastapi.responses import HTMLResponse, RedirectResponse, PlainTextResponse
from fastapi.templating import Jinja2Templates

CSV_DIR = pathlib.Path("/apps/sp_hfts/latency_csv"); CSV_DIR.mkdir(parents=True, exist_ok=True)
BASE_DIR = pathlib.Path(__file__).parent
LOG_FILE = BASE_DIR / "portal.log"
DB_PATH  = str(CSV_DIR / "runs.db")
TPL_DIR  = BASE_DIR / "templates"

logging.basicConfig(level=logging.INFO,
                    format="%(asctime)s  %(levelname)-8s %(message)s",
                    handlers=[logging.FileHandler(LOG_FILE, encoding="utf-8"),
                              logging.StreamHandler()])
log = logging.getLogger("latency-portal")

app       = FastAPI(title="Latency-Portal")
templates = Jinja2Templates(directory=str(TPL_DIR))

# ─── DB ───────────────────────────────────────────────────────────────────────
def _init_db() -> None:
    with sqlite3.connect(DB_PATH) as c:
        c.execute("""CREATE TABLE IF NOT EXISTS runs(
            id          TEXT PRIMARY KEY,
            filename    TEXT,
            created_at  TEXT,
            p50         REAL, p95 REAL, p99 REAL,
            stdev       REAL, count INTEGER,
            approved    INTEGER DEFAULT 0,
            approved_by TEXT, approved_at TEXT,
            png_b64     TEXT );""")
_init_db()

def _row_to_dict(row) -> dict:
    keys=("id","filename","created_at","p50","p95","p99","stdev","count",
          "approved","approved_by","approved_at","png_b64")
    return dict(zip(keys,row))

# ─── CSV ingestion (unchanged) ───────────────────────────────────────────────
def _ingest_new_files() -> None:
    with sqlite3.connect(DB_PATH) as c:
        known = {r[0] for r in c.execute("SELECT id FROM runs")}
    for csv_path in CSV_DIR.glob("*.csv"):
        run_id = csv_path.stem
        if run_id in known: continue
        try:
            df = pd.read_csv(csv_path, skipinitialspace=True,
                    names=["entry_id","ingress","egress","latency_ns"],
                    header=0, dtype={"ingress":"int64","latency_ns":"int64"},
                    engine="python")
        except Exception as exc:
            log.error("Failed to parse %s: %s", csv_path.name, exc); continue
        if df.empty: log.error("Empty CSV %s", csv_path.name); continue
        df.sort_values("ingress", inplace=True)
        lat = df["latency_ns"]
        p50,p95,p99 = (lat.quantile(q) for q in (0.5,0.95,0.99))
        stdev = statistics.pstdev(lat)
        fig, ax = plt.subplots(); ax.plot(df["ingress"], lat, linewidth=0.5)
        ax.set_xlabel("Ingress ns"); ax.set_ylabel("Latency ns"); ax.set_title(run_id)
        buf = io.BytesIO(); fig.savefig(buf, format="png", dpi=110, bbox_inches="tight")
        plt.close(fig); png_b64 = base64.b64encode(buf.getvalue()).decode()
        with sqlite3.connect(DB_PATH) as c:
            c.execute("INSERT INTO runs VALUES (?,?,?,?,?,?,?,?,?,?,?,?)",
                      (run_id, csv_path.name, dt.datetime.utcnow().isoformat(),
                       p50,p95,p99,stdev,len(lat),0,None,None,png_b64))
        log.info("Ingested %s", csv_path.name)

@app.middleware("http")
async def auto_ingest(request: Request, call_next):
    _ingest_new_files(); return await call_next(request)

# ─── Helpers ─────────────────────────────────────────────────────────────────
def _per_second_quantiles(df) -> Tuple[List[str], List[float], List[float], List[float]]:
    df["sec"] = (df["ingress"] // 1_000_000_000)
    grouped   = df.groupby("sec")["latency_ns"]
    p50 = grouped.quantile(0.50); p95 = grouped.quantile(0.95); p99 = grouped.quantile(0.99)
    idx_iso = pd.to_datetime(p50.index.astype("int64"), unit="s", utc=True)\
                 .strftime("%Y-%m-%dT%H:%M:%SZ").tolist()
    return idx_iso, p50.tolist(), p95.tolist(), p99.tolist()

def _load_run_meta(run_id: str) -> dict:
    with sqlite3.connect(DB_PATH) as c:
        row = c.execute("SELECT * FROM runs WHERE id=?", (run_id,)).fetchone()
    if not row:
        raise HTTPException(404, "run not found")
    return _row_to_dict(row)

def _load_run_df_by_meta(meta: dict) -> pd.DataFrame:
    csv_path = CSV_DIR / meta["filename"]
    if not csv_path.exists():
        raise HTTPException(500, "CSV missing")
    df = pd.read_csv(csv_path, skipinitialspace=True,
        names=["entry_id","ingress","egress","latency_ns"], header=0,
        dtype={"ingress":"int64","latency_ns":"int64"}, engine="python"
    ).sort_values("ingress")
    return df

def _summary_stats(lat: pd.Series) -> Dict[str, float]:
    lat = pd.to_numeric(lat, errors="coerce").dropna()
    if lat.empty:
        return {}
    q = lat.quantile([0.5, 0.95, 0.99, 0.999])
    median = float(q.loc[0.5])
    mad = float((lat - median).abs().median())
    madn = float(1.4826 * mad) if mad > 0 else 0.0   # robust σ
    iqr  = float(lat.quantile(0.75) - lat.quantile(0.25))
    mean = float(lat.mean())
    stdev = float(statistics.pstdev(lat))
    denom = madn if madn > 0 else 1.0
    robust_z = ((lat - median).abs() / denom)
    outlier_rate = float((robust_z > 3.5).mean())
    return {
        "p50": float(q.loc[0.5]),
        "p95": float(q.loc[0.95]),
        "p99": float(q.loc[0.99]),
        "p999": float(q.loc[0.999]),
        "mean": mean,
        "stdev": stdev,
        "madn": madn,
        "iqr": iqr,
        "min": float(lat.min()),
        "max": float(lat.max()),
        "count": int(lat.size),
        "outlier_rate": outlier_rate,
    }

def _find_default_baseline_id(current_id: str) -> Optional[str]:
    with sqlite3.connect(DB_PATH) as c:
        row = c.execute("SELECT created_at FROM runs WHERE id=?", (current_id,)).fetchone()
        if not row:
            return None
        created_at = row[0]
        r = c.execute("""SELECT id FROM runs
                         WHERE approved=1 AND created_at < ?
                         ORDER BY created_at DESC LIMIT 1""", (created_at,)).fetchone()
        if r:
            return r[0]
        r = c.execute("""SELECT id FROM runs
                         WHERE created_at < ?
                         ORDER BY created_at DESC LIMIT 1""", (created_at,)).fetchone()
        return r[0] if r else None

def _baseline_candidates(current_created_at: str, limit:int=100) -> List[dict]:
    with sqlite3.connect(DB_PATH) as c:
        rows = c.execute(
            """SELECT id,created_at,approved,p50,p95,p99,stdev,count
               FROM runs
               WHERE created_at < ?
               ORDER BY created_at DESC
               LIMIT ?""",
            (current_created_at, int(limit))
        ).fetchall()
    keys=("id","created_at","approved","p50","p95","p99","stdev","count")
    return [dict(zip(keys,r)) for r in rows]

# ─── Routes ──────────────────────────────────────────────────────────────────
@app.get("/", response_class=HTMLResponse)
def list_runs(request: Request):
    with sqlite3.connect(DB_PATH) as c:
        rows=c.execute("SELECT * FROM runs ORDER BY created_at DESC").fetchall()
    return templates.TemplateResponse("list.html", {"request":request,"runs":[_row_to_dict(r) for r in rows]})

@app.get("/approved", response_class=HTMLResponse)
def approved(request: Request):
    with sqlite3.connect(DB_PATH) as c:
        rows=c.execute("SELECT * FROM runs WHERE approved=1 ORDER BY created_at DESC").fetchall()
    return templates.TemplateResponse("list.html", {"request":request,"runs":[_row_to_dict(r) for r in rows]})

@app.get("/runs/latest")
def latest_redirect():
    with sqlite3.connect(DB_PATH) as c:
        row=c.execute("SELECT id FROM runs ORDER BY created_at DESC LIMIT 1").fetchone()
    if not row: raise HTTPException(404,"No runs")
    return RedirectResponse(f"/runs/{row[0]}", status_code=303)

@app.get("/runs/{run_id}", response_class=HTMLResponse)
def show_run(request: Request, run_id:str):
    with sqlite3.connect(DB_PATH) as c:
        row=c.execute("SELECT * FROM runs WHERE id=?", (run_id,)).fetchone()
    if not row: raise HTTPException(404)
    d=_row_to_dict(row)

    # Load CSV
    csv_path=CSV_DIR/d["filename"]
    if not csv_path.exists(): raise HTTPException(500,"CSV missing")
    df=pd.read_csv(csv_path, skipinitialspace=True,
        names=["entry_id","ingress","egress","latency_ns"], header=0,
        dtype={"ingress":"int64","latency_ns":"int64"}, engine="python").sort_values("ingress")
    df["ingress_dt"]=pd.to_datetime(df["ingress"], unit="ns", utc=True)

    # Raw plot data (current only)
    x_json=json.dumps(df["ingress_dt"].dt.strftime("%Y-%m-%dT%H:%M:%S.%fZ").tolist())
    y_json=json.dumps(df["latency_ns"].tolist())

    # Per-second quantiles (current only)
    sec_iso,p50s,p95s,p99s=_per_second_quantiles(df)

    # Robust stats (current run)
    stats = _summary_stats(df["latency_ns"])

    # Current CDF (no numpy)
    points = 300
    ps = [(i+1)/(points+1) for i in range(points)]
    qs = df["latency_ns"].quantile(ps).astype(float).tolist()

    # Baseline options & auto-select
    baseline_default = _find_default_baseline_id(run_id) or ""
    baseline_runs    = _baseline_candidates(d["created_at"], limit=100)

    return templates.TemplateResponse("detail.html",
        {"request":request, **d,
         "x_json":x_json, "y_json":y_json,
         "sec_json":json.dumps(sec_iso),
         "p50_json":json.dumps(p50s),
         "p95_json":json.dumps(p95s),
         "p99_json":json.dumps(p99s),
         "baseline_default": baseline_default,
         "baseline_runs": baseline_runs,
         "stats_json": json.dumps(stats),
         "cdf_p_json": json.dumps(ps),
         "cdf_q_json": json.dumps(qs)})

@app.post("/runs/{run_id}/approve")
def approve(run_id:str, user:str=Form("anon")):
    now=dt.datetime.utcnow().isoformat()
    with sqlite3.connect(DB_PATH) as c:
        changed=c.execute("UPDATE runs SET approved=1,approved_by=?,approved_at=? WHERE id=? AND approved=0",
                          (user,now,run_id)).rowcount
    if changed==0: raise HTTPException(409,"already approved or missing")
    return RedirectResponse(f"/runs/{run_id}", status_code=303)

@app.post("/runs/{run_id}/unapprove")
def unapprove(run_id:str):
    with sqlite3.connect(DB_PATH) as c:
        changed=c.execute("UPDATE runs SET approved=0,approved_by=NULL,approved_at=NULL WHERE id=? AND approved=1",
                          (run_id,)).rowcount
    if changed==0: raise HTTPException(409,"not approved or missing")
    return RedirectResponse(f"/runs/{run_id}", status_code=303)

@app.get("/runs/{run_id}/status")
def status(run_id:str):
    with sqlite3.connect(DB_PATH) as c:
        row=c.execute("SELECT approved FROM runs WHERE id=?", (run_id,)).fetchone()
    if not row: raise HTTPException(404)
    return {"run_id":run_id,"approved":bool(row[0])}

@app.get("/logs", response_class=PlainTextResponse)
def view_logs(lines:int=1000):
    try:
        with open(LOG_FILE,"r",encoding="utf-8") as f:
            return PlainTextResponse("".join(f.readlines()[-lines:]))
    except FileNotFoundError: raise HTTPException(404,"log missing")

# ─── Lightweight JSON for overlays/compare ───────────────────────────────────
@app.get("/runs/{run_id}/per_second_json")
def per_second_json(run_id:str):
    meta = _load_run_meta(run_id)
    df   = _load_run_df_by_meta(meta)
    sec_iso,p50s,p95s,p99s=_per_second_quantiles(df)
    return {"run_id":run_id,"sec":sec_iso,"p50":p50s,"p95":p95s,"p99":p99s}

@app.get("/runs/{run_id}/summary_json")
def summary_json(run_id:str):
    meta = _load_run_meta(run_id)
    df   = _load_run_df_by_meta(meta)
    s    = _summary_stats(df["latency_ns"])
    s.update({"run_id":run_id,"created_at":meta["created_at"],"approved":bool(meta["approved"])})
    return s

@app.get("/runs/{run_id}/cdf_json")
def cdf_json(run_id:str, points:int=300):
    points = max(50, min(int(points), 2000))
    meta = _load_run_meta(run_id)
    df   = _load_run_df_by_meta(meta)
    lat  = pd.to_numeric(df["latency_ns"], errors="coerce").dropna()
    if lat.empty:
        return {"run_id":run_id,"p":[],"q_ns":[]}
    ps   = [(i+1)/(points+1) for i in range(points)]
    qs   = lat.quantile(ps).astype(float).tolist()
    return {"run_id":run_id,"p":ps,"q_ns":qs}

@app.get("/runs/{run_id}/compare")
def compare_runs(run_id:str, baseline_id:str):
    base_meta = _load_run_meta(baseline_id)
    cur_meta  = _load_run_meta(run_id)
    base_df   = _load_run_df_by_meta(base_meta)
    cur_df    = _load_run_df_by_meta(cur_meta)
    base = _summary_stats(base_df["latency_ns"])
    cur  = _summary_stats(cur_df["latency_ns"])

    def diff(a:float,b:float):
        if b == 0:
            return {"abs": a-b, "pct": None}
        return {"abs": a-b, "pct": (a-b)/b*100.0}

    metrics = ["p50","p95","p99","p999","stdev","madn","iqr","mean","outlier_rate","count"]
    delta = {m: diff(cur.get(m,0.0), base.get(m,0.0)) for m in metrics}
    return {"run_id":run_id, "baseline_id":baseline_id,
            "current":cur, "baseline":base, "delta":delta}

















{% extends 'base.html' %}{% block title %}Run {{ id }}{% endblock %}
{% block content %}
<style>
  /* SaaS-like polish without external deps */
  .page-header { display:flex; justify-content:space-between; align-items:start; gap:1rem; }
  .page-title { margin:0; }
  .subtext { color:#6c757d; font-size:.9rem; }
  .pill { display:inline-flex; align-items:center; gap:.35rem; padding:.25rem .5rem; border-radius:999px; background:#f8f9fa; border:1px solid #e9ecef; font-size:.85rem; }
  .pill .label { color:#6c757d; }
  .pill .value { font-weight:600; }
  .metric-row { display:flex; flex-wrap:wrap; gap:.5rem .75rem; }
  .card-clean { border:1px solid #e9ecef; border-radius:.5rem; }
  .card-clean .card-header { background:#fff; border-bottom:1px solid #e9ecef; }
  .delta-chip { padding:.25rem .5rem; border-radius:.5rem; font-weight:600; }
  .delta-up { color:#842029; background:#f8d7da; }     /* regression (higher is worse) */
  .delta-down { color:#0f5132; background:#d1e7dd; }   /* improvement (lower is better) */
  .muted { color:#6c757d; }
  .tab-pane { padding-top:1rem; }
</style>

<div class="page-header mb-3">
  <div>
    <h3 class="page-title">Run {{ id }}</h3>
    <div class="subtext">{{ created_at[:19] }} UTC
      {% if approved %}· <span class="text-success">APPROVED</span>
      {% else %}· <span class="text-danger">PENDING</span>{% endif %}
    </div>
    <!-- Quick key metrics (original set, concise) -->
    <div class="metric-row mt-2">
      <span class="pill" data-bs-toggle="tooltip" title="50 % of latencies are below this value (median)">
        <span class="label">P50</span><span class="value">{{ '%.0f'|format(p50) }} ns</span>
      </span>
      <span class="pill" data-bs-toggle="tooltip" title="95th percentile latency">
        <span class="label">P95</span><span class="value">{{ '%.0f'|format(p95) }} ns</span>
      </span>
      <span class="pill" data-bs-toggle="tooltip" title="99th percentile latency">
        <span class="label">P99</span><span class="value">{{ '%.0f'|format(p99) }} ns</span>
      </span>
      <span class="pill" data-bs-toggle="tooltip" title="Population standard deviation">
        <span class="label">σ</span><span class="value">{{ '%.0f'|format(stdev) }} ns</span>
      </span>
      <span class="pill" data-bs-toggle="tooltip" title="Total samples">
        <span class="label">n</span><span class="value">{{ count }}</span>
      </span>
    </div>
  </div>

  <!-- Baseline selector -->
  <div>
    <label class="form-label mb-1">Baseline</label>
    <select id="baselineSelect" class="form-select form-select-sm" style="min-width: 300px;">
      <option value="" {% if not baseline_default %}selected{% endif %}>— none —</option>
      {% for r in baseline_runs %}
        <option value="{{ r.id }}" {% if baseline_default and r.id == baseline_default %}selected{% endif %}>
          {{ r.id }} · {{ r.created_at[:19] }} UTC{% if r.approved %} ✓{% endif %}
        </option>
      {% endfor %}
    </select>
    <div class="form-text">Used for CDF overlay and deltas.</div>
  </div>
</div>

<!-- Comparison summary (compact) -->
<div id="delta-summary" class="row g-2 mb-3" style="display:none;">
  <div class="col-auto"><span class="muted">Δ vs baseline:</span></div>
  <div class="col-auto"><span id="d-p50"  class="delta-chip"></span></div>
  <div class="col-auto"><span id="d-p95"  class="delta-chip"></span></div>
  <div class="col-auto"><span id="d-p99"  class="delta-chip"></span></div>
  <div class="col-auto"><span id="d-p999" class="delta-chip"></span></div>
  <div class="col-auto"><span id="d-or"   class="delta-chip"></span></div>
</div>

<!-- Tabs: Distribution first (most meaningful), then Quantiles & Raw -->
<ul class="nav nav-tabs" id="viewTabs" role="tablist">
  <li class="nav-item" role="presentation">
    <button class="nav-link active" id="tab-cdf" data-bs-toggle="tab" data-bs-target="#pane-cdf" type="button" role="tab">Distribution (CDF)</button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="tab-quant" data-bs-toggle="tab" data-bs-target="#pane-quant" type="button" role="tab">Per‑second Quantiles</button>
  </li>
  <li class="nav-item" role="presentation">
    <button class="nav-link" id="tab-raw" data-bs-toggle="tab" data-bs-target="#pane-raw" type="button" role="tab">Raw Messages</button>
  </li>
</ul>

<div class="tab-content">
  <div class="tab-pane fade show active" id="pane-cdf" role="tabpanel" aria-labelledby="tab-cdf">
    <div id="cdfplot" style="height:380px;"></div>
    <div class="form-check mt-2">
      <input class="form-check-input" type="checkbox" id="toggleBaselineCDF" checked>
      <label class="form-check-label" for="toggleBaselineCDF">Overlay baseline on CDF</label>
    </div>
  </div>
  <div class="tab-pane fade" id="pane-quant" role="tabpanel" aria-labelledby="tab-quant">
    <div id="quantplot" style="height:360px;"></div>
    <div class="form-text">Current run only (no overlay) — use CDF for baseline comparison.</div>
  </div>
  <div class="tab-pane fade" id="pane-raw" role="tabpanel" aria-labelledby="tab-raw">
    <div id="rawplot" style="height:360px;"></div>
    <div class="form-text">Dense time series for shape only; not used for approval.</div>
  </div>
</div>

<!-- Robust stats with succinct explanations -->
<div class="card card-clean mt-4">
  <div class="card-header"><strong>Current run — robust stats</strong></div>
  <div class="card-body">
    <div class="row row-cols-2 row-cols-md-3 row-cols-lg-4 g-3" id="current-stats"></div>
    <details class="mt-2">
      <summary class="small text-muted">What do these mean?</summary>
      <ul class="small mb-0">
        <li><b>P99.9</b>: 99.9th percentile (ultra-tail).</li>
        <li><b>MAD<span style="font-size:0.8em;vertical-align:super;">n</span></b>: robust σ ≈ 1.4826×MAD (less sensitive to outliers).</li>
        <li><b>IQR</b>: 75th–25th percentile spread (bulk dispersion).</li>
        <li><b>Outlier rate</b>: share of samples with robust z-score &gt; 3.5 (Hampel proxy).</li>
      </ul>
    </details>
  </div>
</div>

<!-- Approval actions (unchanged logic, just placed at end) -->
{% if approved %}
  <div class="alert alert-success mt-4 d-flex justify-content-between align-items-center">
    <span>Approved by <b>{{ approved_by }}</b> at {{ approved_at[:19] }} UTC</span>
    <form action="/runs/{{ id }}/unapprove" method="post">
      <button class="btn btn-outline-danger btn-sm" data-bs-toggle="tooltip" title="Mark this run as not approved">Un‑approve</button>
    </form>
  </div>
{% else %}
  <form class="mt-4" action="/runs/{{ id }}/approve" method="post">
    <div class="input-group w-auto">
      <input class="form-control form-control-sm" name="user" placeholder="Your name">
      <button class="btn btn-success btn-sm">Approve</button>
    </div>
  </form>
{% endif %}

<script>
  // -------- Helpers
  const fmtInt = (v)=> (v===null||v===undefined) ? '–' : Math.round(v).toLocaleString('en');
  const fmtNs  = (v)=> (v===null||v===undefined) ? '–' : Math.round(v).toLocaleString('en') + ' ns';
  const fmtPct = (v)=> (v===null||v===undefined) ? '–' : v.toFixed(2) + ' %';

  // -------- Current-run robust stats
  (function renderCurrentStats(){
    const s = {{ stats_json|safe }};
    const items = [
      {k:'p999',lbl:'P99.9',fmt:fmtNs, tip:'99.9th percentile'},
      {k:'madn',lbl:'MAD\u2099',fmt:fmtNs, tip:'Robust σ ≈ 1.4826×MAD'},
      {k:'iqr', lbl:'IQR',  fmt:fmtNs, tip:'75th–25th percentile'},
      {k:'outlier_rate',lbl:'Outlier rate',fmt:(v)=>fmtPct(v*100), tip:'Robust z > 3.5'},
      {k:'mean',lbl:'Mean',fmt:fmtNs, tip:'Arithmetic mean'},
      {k:'stdev',lbl:'σ',fmt:fmtNs, tip:'Population standard deviation'},
      {k:'min',lbl:'Min',fmt:fmtNs, tip:'Minimum latency'},
      {k:'max',lbl:'Max',fmt:fmtNs, tip:'Maximum latency'},
    ];
    const box = document.getElementById('current-stats');
    items.forEach(it=>{
      const v = s[it.k]; const val = it.fmt(v);
      const div = document.createElement('div');
      div.innerHTML = `
        <div class="border rounded p-2 h-100" data-bs-toggle="tooltip" title="${it.tip}">
          <div class="text-muted small">${it.lbl}</div>
          <div class="fw-semibold">${val}</div>
        </div>`;
      box.appendChild(div);
    });
    if (window.bootstrap){
      [...document.querySelectorAll('[data-bs-toggle="tooltip"]')].forEach(el=>new bootstrap.Tooltip(el));
    }
  })();

  // -------- CDF (current + optional baseline overlay)
  const CURRENT_CDF = { p: {{ cdf_p_json|safe }}, q_ns: {{ cdf_q_json|safe }}, run_id: "{{ id }}" };
  let baselineCDF = null;

  function renderCDF(){
    const showBaseline = document.getElementById('toggleBaselineCDF').checked;
    const data = [{
      x: CURRENT_CDF.q_ns, y: CURRENT_CDF.p.map(p=>p*100),
      name: `${CURRENT_CDF.run_id}`, mode:'lines'
    }];
    if (baselineCDF && showBaseline){
      data.push({
        x: baselineCDF.q_ns, y: baselineCDF.p.map(p=>p*100),
        name: `${baselineCDF.run_id} (baseline)`, mode:'lines', line:{dash:'dot'}
      });
    }
    Plotly.react('cdfplot', data, {
      title:'Latency distribution (CDF)',
      margin:{l:40,r:20,t:40,b:40},
      xaxis:{title:'Latency (ns)'},
      yaxis:{title:'Cumulative (%)', range:[0,100]}
    });
  }

  document.getElementById('toggleBaselineCDF').addEventListener('change', renderCDF);

  // -------- Quantiles & Raw (render on first tab show for proper sizing)
  let quantReady=false, rawReady=false;
  document.getElementById('viewTabs').addEventListener('shown.bs.tab', (e)=>{
    const id = e.target.getAttribute('data-bs-target');
    if (id === '#pane-quant' && !quantReady){
      Plotly.newPlot('quantplot', [
        {x:{{ sec_json|safe }}, y:{{ p50_json|safe }}, name:'P50', mode:'lines'},
        {x:{{ sec_json|safe }}, y:{{ p95_json|safe }}, name:'P95', mode:'lines'},
        {x:{{ sec_json|safe }}, y:{{ p99_json|safe }}, name:'P99', mode:'lines'}
      ], {
        title:'Per-second quantiles (current)',
        margin:{l:40,r:20,t:40,b:40},
        xaxis:{title:'Time (1-s buckets)', type:'date'},
        yaxis:{title:'Latency (ns)'}
      });
      quantReady=true;
    }
    if (id === '#pane-raw' && !rawReady){
      Plotly.newPlot('rawplot', [{x:{{ x_json|safe }}, y:{{ y_json|safe }}, mode:'lines', line:{width:1}}], {
        title:'Latency per message (current)',
        margin:{l:40,r:20,t:40,b:40},
        xaxis:{title:'Ingress time', type:'date'},
        yaxis:{title:'Latency (ns)'}
      });
      rawReady=true;
    }
  });

  // -------- Baseline selection: overlay CDF + compact delta chips + (optional) table
  function paintDelta(el, valueAbs, valuePct, lowerIsBetter=true, unit='ns'){
    if (valueAbs==null || isNaN(valueAbs)) { el.style.display='none'; return; }
    const regresses = lowerIsBetter ? (valueAbs>0) : (valueAbs<0);
    el.className = 'delta-chip ' + (regresses ? 'delta-up' : 'delta-down');
    const arrow = regresses ? '↑' : '↓';
    const pctTxt = (valuePct==null || isNaN(valuePct)) ? '' : ` (${valuePct.toFixed(2)}%)`;
    el.textContent = `${arrow} ${Math.round(valueAbs)} ${unit}${pctTxt}`;
    el.style.display='';
  }

  async function updateComparison(baselineId){
    const summary = document.getElementById('delta-summary');
    if (!baselineId){
      baselineCDF = null; renderCDF(); summary.style.display='none';
      return;
    }
    // fetch CDF for overlay
    baselineCDF = await (await fetch(`/runs/${baselineId}/cdf_json?points=300`)).json();
    renderCDF();

    // fetch deltas
    const cmp = await (await fetch(`/runs/{{ id }}/compare?baseline_id=${baselineId}`)).json();
    summary.style.display='flex';

    // p50/p95/p99/p999 deltas (lower is better)
    paintDelta(document.getElementById('d-p50'),  cmp.delta.p50.abs,  cmp.delta.p50.pct,  true, 'ns');
    paintDelta(document.getElementById('d-p95'),  cmp.delta.p95.abs,  cmp.delta.p95.pct,  true, 'ns');
    paintDelta(document.getElementById('d-p99'),  cmp.delta.p99.abs,  cmp.delta.p99.pct,  true, 'ns');
    paintDelta(document.getElementById('d-p999'), cmp.delta.p999.abs, cmp.delta.p999.pct, true, 'ns');
    // outlier rate (lower is better) – show as percentage
    const orAbsPct = (cmp.delta.outlier_rate.abs ?? 0) * 100;
    const orPctPct = (cmp.delta.outlier_rate.pct==null) ? null : cmp.delta.outlier_rate.pct;
    paintDelta(document.getElementById('d-or'), orAbsPct, orPctPct, true, '%');
  }

  const sel = document.getElementById('baselineSelect');
  sel.addEventListener('change', (e)=> updateComparison(e.target.value));

  // Auto-load default baseline if present
  {% if baseline_default %}
    updateComparison("{{ baseline_default }}");
  {% endif %}

  // Initialize CDF immediately (without baseline)
  renderCDF();
</script>
{% endblock %}




