# GTAd Lab Mode Initiative - Historical Clock Implementation

**Document Status:** Technical Proposal - DRAFT  
**Location:** Pages / Trading Services / Framework / GTAd  
**Author:** Meric Song  
**Reviewer:** William Murray  
**Date:** January 2024  
**JIRA:** CTS-8615

---

## Summary

This proposal implements a historical clock mode for GTAd to enable deterministic replay of order event sequence for GTA strategies. By using market data packet timestamps and "next packet timestamp" information, we can fire timers at their originally scheduled orders.

Because active timer slot container is `std::multiset` with comparator defined in terms of expiry time, looping over this container expiring by one, advancing historical clock every time an event expires, would deterministically recreate production behaviour.

This is essential for accurate latency analysis in lab environments.

---

## Flowchart Structure

### Main Framework Loop

```mermaid
flowchart TD
    subgraph "Main Framework Loop"
        direction TB
        
        %% Polling Sequence
        FEED_POLL["Poll Inline Feeds"] --> GW_POLL["Poll Gateway"]
        GW_POLL --> GW_SCHEDULE["Schedule Gateway Events for determinism"]
        GW_SCHEDULE --> LMX_POLL["Poll LMX / Link Manager"]
        LMX_POLL --> FPGA_POLL["Poll FPGA"]
        
        %% Event Processing
        FPGA_POLL --> EVENT_QUEUE
        
        subgraph EVENT_QUEUE["Event Queue Loop"]
            direction TB
            EVENT_HANDLER["Process a single event (e.g., on_market_data)"]
            TIMER_CHECK["Expire all timers between current and Next packet timestamp"]
            ADVANCE_CLOCK["Advance historical clock up until latest alarm expiry"]
            QUEUE_EMPTY["Is StrategyQueue empty?"]
            
            EVENT_HANDLER --> TIMER_CHECK
            TIMER_CHECK --> ADVANCE_CLOCK
            ADVANCE_CLOCK --> QUEUE_EMPTY
        end
        
        QUEUE_EMPTY -->|Yes| PROCESSED_CHECK["Was any event processed?"]
        QUEUE_EMPTY -->|No| EVENT_HANDLER
        PROCESSED_CHECK -->|Yes| ON_EMPTY_QUEUE_CB["Call onEmptyEventQueue()"]
        PROCESSED_CHECK -->|No| FEED_POLL
        ON_EMPTY_QUEUE_CB --> FEED_POLL
    end
```

### Architecture Overview

The proposed architecture shows:
- Net LNX / Link Manager connected to Net FPGA
- Universally accessible event clock (historical clock) that overrides a common interface
- Both lab mode historical clock and production mode real system clock expose the same interface for code cleanness
- Expected behavior includes advancing timestamp of market data packets on ingress and expiring timestamp of timers being expired
- Each market data packet IPv4 header Options section to be edited using tcprewrite or to contain timestamp of current & next MD packet timestamps

---

## Implementation Details

### 1. Compile-Time Clock Selection (Based on Manager's Git Diff)

**File Structure:**
```
src/chrono/
├── clock.h              # Common interface
├── CMakeLists.txt       # Build configuration
├── realtime/
│   └── clock.cpp        # Production implementation
└── historical/
    └── clock.cpp        # Lab mode implementation
```

**clock.h** - Common Interface:
```cpp
#pragma once
#include <chrono>

namespace util::chrono {

struct Clock {
    using duration = std::chrono::nanoseconds;
    using rep = duration::rep;
    using period = duration::period;
    using time_point = std::chrono::time_point<Clock>;
    static constexpr bool is_steady = false;
    
    static time_point now();
};

// Only available in historical build
#ifdef GTAD_LAB_BUILD
void advanceTime(std::chrono::nanoseconds newTime);
#endif

} // namespace util::chrono
```

**CMakeLists.txt:**
```cmake
# src/CMakeLists.txt
add_subdirectory(frameworkEvents)
add_subdirectory(binary_dropcopy)
add_subdirectory(marketDataFeedService)
+ add_subdirectory(chrono)

# src/chrono/CMakeLists.txt
set(hdrs clock.h)

# Production clock library
sp_add_library_ext(rchrono SHARED SOURCES ${hdrs} realtime/clock.cpp
    COMPONENT runtime)

# Historical clock library  
sp_add_library_ext(hchrono SHARED SOURCES ${hdrs} historical/clock.cpp
    COMPONENT historical)

# src/gtad/CMakeLists.txt
sp_add_executable_ext(gtad
    SOURCES ${XSD_SOURCES} GTAd.cpp GTADFramework.cpp main.cpp
    LINK_LIBS -Wl,--export-dynamic rchrono gtad_obj enyx
    COMPONENT runtime)

sp_add_executable_ext(gtad_lab
    SOURCES ${XSD_SOURCES} GTAd.cpp GTADFramework.cpp main.cpp
    LINK_LIBS -Wl,--export-dynamic hchrono gtad_obj enyx
    COMPONENT runtime)

target_compile_definitions(gtad_lab PRIVATE GTAD_LAB_BUILD)
```

### 2. Timer.h Modifications

```cpp
// Timer.h
- #include "util/real_clock.h"
+ #include "chrono/clock.h"

struct TimerExpiryWatcher {
    std::chrono::nanoseconds now() const {
-       return ::util::real_clock::RealtimeClock::now().time_since_epoch();
+       return ::util::chrono::Clock::now().time_since_epoch();
    }
};

- using spappTimerManager = sp::event::timer_manager<::util::real_clock::RealtimeClock, TimerExpiryWatcherWrapper>;
+ using spappTimerManager = sp::event::timer_manager<::util::chrono::Clock, TimerExpiryWatcherWrapper>;
```

### 3. Add Next Packet Timestamp to Events

**Framework/Events.h:**
```cpp
struct MDBoE {
    MDSnapshot snapshot;
    LatencyContext mdLatency;
+   std::optional<std::chrono::nanoseconds> nextPacketTimestamp;
};
```

> **William's Comment #1 (Aug 20, 2025):**  
> "std::optional for nextPacketTimestamp: aren't we saying it'll always be there?"  
> "Also in reality how are we going to gain access to the value of next packet timestamp at the point in time MDBoE is constructed which is here: https://gitlab.sgx-serpent.com/tck/framework/gtad/-/blob/v10.5.0/src/marketdataServices/MarketDataReadLowLate..."

**Response:** Made it `std::optional` because:
- Production packets won't have this field
- Lab replay tool will populate it via lookahead buffer
- Accessed at packet construction time in replay tool, not in MarketDataReadLowLatency

### 4. Process Market Data with Historical Clock

**GTADFramework.cpp:**
```cpp
void operator()(const frameworkEvents::MDBoE& event) {
    // Process market data FIRST (matches production behavior)
    framework_.strategy_.on_market_data(framework_.thread_.queue_.size(), 
                                       event.snapshot, event.mdLatency);
    
#ifdef GTAD_LAB_BUILD
    // THEN advance clock and check timers (after MD processing)
    auto eventTime = std::chrono::nanoseconds(event.snapshot.m_exchange_time_64);
    ::util::chrono::advanceTime(eventTime);
    
    // Fire timers up to next packet (if available)
    if (event.nextPacketTimestamp.has_value()) {
        framework_.timer_mgr_.expire(event.nextPacketTimestamp.value());
    } else {
        framework_.timer_mgr_.expire(eventTime);
    }
#endif
}
```

> **William's Comment #2 (Aug 20, 2025):**  
> "That looks very much like expiring timers before processing MD. Doesn't align with above diagram where they're expiring after processing MD"

**Response:** Corrected - timers now fire AFTER market data processing to match production behavior and the flowchart.

---

## Safety Mechanisms

### Production Safety Requirements

> **William's Comment #3 (Aug 20, 2025):**  
> "Needs beefing up. 'Use CHEF'... how? What checks, what fields to depend on?"  
> "Can't we just have a white list of LAB hosts (stored in GIT somewhere) then change GTAdStart on those hosts?"  
> "Would require changing GTAdStart to have some 'labMode' switch, but isn't some rascal first launching GTAd in some other way via Jenkins or other than what's in the white list a bit obvious?"  
> "Caveat: it wouldn't protect against a user manually running 'gtad -c strat.xml'. Do we need to be worried about this?"

**Response - Multi-Layer Protection:**

1. **Binary Separation** (Primary Defense)
   ```
   gtad     → Production binary (links rchrono)
   gtad-lab → Lab binary (links hchrono)
   ```

2. **Host Whitelist** (/etc/gtad/lab-hosts.whitelist)
   ```bash
   # Stored in Git, deployed via Chef
   lab-gtad-01
   lab-gtad-02
   dev-meric-01
   ```

3. **GTAdStart Script**
   ```bash
   #!/bin/bash
   HOSTNAME=$(hostname)
   
   # Check whitelist
   if grep -q "$HOSTNAME" /etc/gtad/lab-hosts.whitelist; then
       if [[ "$1" == "--lab-mode" ]]; then
           exec /opt/gtad/bin/gtad-lab "${@:2}"
       fi
   fi
   
   # Default to production
   exec /opt/gtad/bin/gtad "$@"
   ```

4. **Manual Execution Protection**
   - Even if someone runs `gtad-lab -c strat.xml` directly:
     - Binary won't exist on production hosts (not deployed)
     - RPM packaging ensures gtad-lab only installs on whitelisted hosts

> **William's Comment #4 (Aug 20, 2025):**  
> "What does it mean to compile with GTAD_LAB_BUILD true? Separate binary I'd guess"

**Response:** Yes, exactly. Two separate binaries:
- `gtad` - Production (no GTAD_LAB_BUILD defined)
- `gtad-lab` - Lab mode (GTAD_LAB_BUILD defined)

> **William's Comment #5 (Aug 20, 2025):**  
> "What is the proposal for enablement of lab mode? I note inclusion of code 'IsLabEnvironment()' but no mention outside of this. Do we consider env var enablement to be robust enough?"

**Response:** No env vars needed. Lab mode is enabled by:
1. Running `gtad-lab` binary (not `gtad`)
2. Binary only exists on whitelisted lab hosts
3. Compile-time separation ensures complete isolation

---

## Expected Behavior

### Production Mode (gtad binary)
- Uses `rchrono` library → `RealtimeClock::now()`
- Timers fire based on wall clock
- No historical clock code compiled in
- Standard event processing flow

### Lab Mode (gtad-lab binary)
- Uses `hchrono` library → `HistoricalClock::now()`
- Clock advances only on market data events
- Timers fire deterministically based on packet timestamps
- Identical event sequence on replay

---

## Testing Strategy

### Unit Tests
```cpp
TEST(ClockLibrary, ProductionUsesRealtime) {
    auto t1 = util::chrono::Clock::now();
    std::this_thread::sleep_for(1ms);
    auto t2 = util::chrono::Clock::now();
    ASSERT_GT(t2, t1);  // Time advances naturally
}

TEST(ClockLibrary, HistoricalIsStatic) {
    auto t1 = util::chrono::Clock::now();
    std::this_thread::sleep_for(1ms);
    auto t2 = util::chrono::Clock::now();
    ASSERT_EQ(t2, t1);  // Time doesn't advance without explicit call
}
```

### Integration Tests
```cpp
TEST(Determinism, ReplayIsIdentical) {
    auto run1 = runReplay("gtad-lab", "test.pcap");
    auto run2 = runReplay("gtad-lab", "test.pcap");
    
    ASSERT_EQ(run1.orderHashes, run2.orderHashes);
    ASSERT_EQ(run1.timerSequence, run2.timerSequence);
}
```

---

## Key Benefits

1. **Complete Isolation** - Lab code cannot run in production
2. **Clean Implementation** - Minimal #ifdefs
3. **Deterministic Replay** - Identical results every run
4. **No Performance Impact** - Production binary unchanged
5. **Clear Separation** - Different binaries for different purposes

---

## Review Comments Resolution Summary

All 5 review comments from William Murray have been addressed:

1. ✅ **nextPacketTimestamp optionality** - Made `std::optional` since production packets won't have it
2. ✅ **Timer firing sequence** - Corrected to fire AFTER market data processing 
3. ✅ **Safety mechanisms** - Implemented host whitelist, binary separation, no manual execution risk
4. ✅ **Separate binary clarification** - Yes, two binaries: `gtad` and `gtad-lab`
5. ✅ **Lab mode enablement** - No env vars, purely binary-based with compile-time separation

---

## Proposed Solution Summary

This document presents a compile-time separated historical clock implementation using:
- CMake-based clock library substitution (as shown in commit 5a9080f9)
- Two binaries: `gtad` (production) and `gtad-lab` (historical mode)
- Host whitelist for deployment control
- Optional next packet timestamp support for realistic replay

This approach addresses all technical concerns raised in the review and provides maximum safety with minimal code complexity.
