# GTAd Historical Clock Implementation for Lab Mode
## Accurate Timer Replay for Latency Analysis

### Executive Summary

This proposal implements a historical clock mode for GTAd to enable accurate replay of timer behavior during backtesting. By using market data packet timestamps and "next packet timestamp" information, we can fire timers at their originally scheduled times rather than batching them at packet arrivals. This is essential for accurate latency analysis in lab environments.

### Key Design Principles

1. **Production binary unchanged** - Uses compile-time flag to create separate lab binary
2. **Minimal code changes** - Surgical modifications to timer infrastructure only  
3. **Zero production risk** - Lab-only features with multiple safety checks
4. **Accurate timing replay** - Timers fire at scheduled times, not packet arrivals

### Architecture Overview

```mermaid
flowchart TB
    subgraph "Production Build (Default)"
        A1[Market Data Event] --> B1[Process MD]
        B1 --> C1[Strategy Logic]
        D1[Real Clock<br/>wall time] --> E1[Timer Check]
        E1 --> F1[Fire Timers]
    end
    
    subgraph "Lab Build (-DGTAD_LAB_BUILD)"
        A2[Market Data Event<br/>+ Next Packet TS] --> B2[Advance Historical Clock]
        B2 --> C2{Next TS<br/>Available?}
        C2 -->|Yes| D2[Fire Timers up to<br/>Next Packet Time]
        C2 -->|No| E2[Fire Timers up to<br/>Current Time]
        D2 --> F2[Process MD]
        E2 --> F2
        F2 --> G2[Strategy Logic]
        
        H2[Historical Clock<br/>packet timestamps] --> I2[Timer Check]
    end
    
    style A2 fill:#9ff,stroke:#333,stroke-width:2px
    style C2 fill:#f9f,stroke:#333,stroke-width:2px
    style H2 fill:#9f9,stroke:#333,stroke-width:2px
```

### Problem: Current Timer Batching in Replay

```mermaid
gantt
    title Current Replay Behavior - Timers Batch at Packet Arrival
    dateFormat X
    axisFormat %L ms
    
    section Events
    Packet 1 arrives         :milestone, p1, 0, 0
    Timer A scheduled        :done, ta, 0, 500
    Timer B scheduled        :done, tb, 0, 1500
    Packet 2 arrives         :milestone, p2, 1000, 0
    Packet 3 arrives         :milestone, p3, 2000, 0
    
    section Actual Firing
    Timer A fires late       :crit, taf, 1000, 0
    Timer B fires late       :crit, tbf, 2000, 0
```

**Issue**: Timer A (scheduled for 500ms) doesn't fire until Packet 2 arrives at 1000ms. This hides 500ms of latency in analysis.

### Solution: Fire Timers Between Packets

```mermaid
gantt
    title Proposed Behavior - Timers Fire at Scheduled Time
    dateFormat X
    axisFormat %L ms
    
    section Events
    Packet 1 arrives         :milestone, p1, 0, 0
    Timer A fires on time    :done, taf, 500, 0
    Packet 2 arrives         :milestone, p2, 1000, 0
    Timer B fires on time    :done, tbf, 1500, 0
    Packet 3 arrives         :milestone, p3, 2000, 0
```

## Implementation

### 1. Compile-Time Clock Selection

**File: Timer.h**
```cpp
#pragma once

#include <chrono>
#include <memory>
#include <spapp/event/timer_manager.hpp>
#include "framework/common.h"
#include "framework/alarm.h"
#include "util/real_clock.h"
#include "util/log.h"

class LatencyContext;

// Single compile-time switch for lab vs production build
#ifdef GTAD_LAB_BUILD

// Lab mode: Historical clock that advances via packet timestamps
class HistoricalClock {
public:
    using duration = std::chrono::nanoseconds;
    using rep = duration::rep;
    using period = duration::period;
    using time_point = std::chrono::time_point<HistoricalClock>;
    static constexpr bool is_steady = false;
    
    static time_point now() {
        return time_point(currentTime_.load(std::memory_order_acquire));
    }
    
    static void advanceTime(std::chrono::nanoseconds newTime) {
        auto oldTime = currentTime_.load();
        if (newTime > oldTime) {
            currentTime_.store(newTime, std::memory_order_release);
        }
    }
    
    static void reset() {
        currentTime_.store(std::chrono::nanoseconds(0));
    }
    
private:
    static std::atomic<std::chrono::nanoseconds> currentTime_;
};

// Static member definition
std::atomic<std::chrono::nanoseconds> HistoricalClock::currentTime_{0};

using ClockType = HistoricalClock;

#else

// Production mode: Use existing real clock
using ClockType = ::util::real_clock::RealtimeClock;

#endif

struct TimerExpiryWatcher
{
    TimerExpiryWatcher() : log_(GTAG_GET_LOGGER("TimerExpiryWatcher"))
    {
    }

    void notify(std::chrono::nanoseconds nextExpiry)
    {
        nextExpiry_ = roundCell(nextExpiry);
    }

    bool nextTimerExpired()
    {
        // Now uses ClockType which is either RealTimeClock or HistoricalClock
        now_ = ClockType::now().time_since_epoch();
        
        if (nextExpiry_ == std::chrono::nanoseconds::zero())
        {
            return false;
        }
        
        if (unlikely(now_ > nextExpiry_))
        {
            GTAG_LOG_DEBUG(log_,
                "Running expired timers for current time, earliest is " << pa::DatePrinter(nextExpiry_));
            return true;
        }
        return false;
    }

    std::chrono::nanoseconds now() const
    {
        return now_;
    }

private:
    // ... existing members ...
};

// Timer manager now uses ClockType (compile-time selected)
using spappTimerManager = sp::event::timer_manager<ClockType, TimerExpiryWatcherWrapper>;

// ... rest of Timer.h unchanged ...
```

### 2. Add Next Packet Timestamp to Events

**File: Frameworks.h**
```cpp
namespace frameworkEvents
{
    struct MDBBOEvent
    {
        MDBBOEvent(px::MDLevelSnapshot snapshot, LatencyContext::MktData mdLatency) :
            snapshot(snapshot), mdLatency(mdLatency)
        {
        }

        px::MDLevelSnapshot snapshot;
        LatencyContext::MktData mdLatency;
        
#ifdef GTAD_LAB_BUILD
        // Only in lab builds - zero overhead in production
        std::optional<std::chrono::nanoseconds> nextPacketTimestamp;
#endif
    };
    
    // Similar additions to other market data events...
}
```

### 3. Process Market Data with Historical Clock

**File: GTADFramework.h**
```cpp
class GTADFramework {
    // ... existing code ...
    
private:
    class StrategyThread final : public service::PinnedThreadedService
    {
        class Processor
        {
            void operator()(const frameworkEvents::MDBBOEvent& event)
            {
#ifdef GTAD_LAB_BUILD
                // Lab mode: Advance historical clock and fire timers between packets
                if (event.snapshot.m_exchange_time_64 > 0) {
                    auto currentPacketTime = std::chrono::nanoseconds(event.snapshot.m_exchange_time_64);
                    
                    // Advance clock to current packet timestamp
                    HistoricalClock::advanceTime(currentPacketTime);
                    
                    // If next packet timestamp available, fire timers up to that point
                    if (event.nextPacketTimestamp && framework_.useNextPacketTimestamp_) {
                        // Fire all timers that expire before next packet
                        // This recreates original timing behavior
                        auto fireUpToTime = *event.nextPacketTimestamp - std::chrono::nanoseconds(1);
                        if (framework_.timerExpiryWatcher_.nextTimerExpired()) {
                            framework_.timer_mgr_.expire(fireUpToTime);
                        }
                    } else {
                        // No next timestamp - just check current time
                        framework_.thread_.checkTimerExpiry();
                    }
                }
#endif
                // Process market data normally
                framework_.strategy_.on_market_data(framework_.thread_.queue_.size(), 
                                                  event.snapshot, event.mdLatency);
            }
            
            // Similar changes for MOAuctionSummaryEvent and MOOpenCloseEvent...
        };
    };
    
#ifdef GTAD_LAB_BUILD
    bool useNextPacketTimestamp_{true};  // Configurable via XML
    
    // Safety check - only enable features if environment allows
    bool isLabEnvironment() const {
        return std::getenv("GTAD_LAB_MODE") != nullptr;
    }
#endif
};
```

### 4. Safety Mechanisms

```mermaid
flowchart TD
    A[Lab Binary Started] --> B{GTAD_LAB_MODE<br/>env var set?}
    B -->|No| C[Fatal Error:<br/>"Lab binary requires<br/>GTAD_LAB_MODE=1"]
    B -->|Yes| D{Hostname Check}
    D -->|Contains 'prod'| E[Fatal Error:<br/>"Cannot run lab binary<br/>on production host"]
    D -->|Lab hostname| F[Initialize with<br/>Historical Clock]
    F --> G{Config: UseNextPacketTS?}
    G -->|Yes| H[Enable Between-Packet<br/>Timer Firing]
    G -->|No| I[Basic Historical Mode]
    
    style C fill:#faa,stroke:#333,stroke-width:2px
    style E fill:#faa,stroke:#333,stroke-width:2px
    style F fill:#afa,stroke:#333,stroke-width:2px
```

**Implementation in GTADFramework constructor:**
```cpp
#ifdef GTAD_LAB_BUILD
    // Lab build safety checks
    if (!isLabEnvironment()) {
        GTAD_LOG_FATAL(log_, "Lab binary requires GTAD_LAB_MODE=1 environment variable");
        throw std::runtime_error("Lab binary safety check failed");
    }
    
    char hostname[256];
    if (gethostname(hostname, sizeof(hostname)) == 0) {
        std::string host(hostname);
        if (host.find("prod") != std::string::npos) {
            GTAD_LOG_FATAL(log_, "Lab binary cannot run on production host: " << host);
            throw std::runtime_error("Lab binary on production host");
        }
    }
    
    GTAD_LOG_INFO(log_, "Lab binary initialized with historical clock support");
    
    // Check config for next packet timestamp usage
    if (cfg.LabMode().present() && cfg.LabMode().get().UseNextPacketTimestamp().present()) {
        useNextPacketTimestamp_ = cfg.LabMode().get().UseNextPacketTimestamp().get();
    }
#endif
```

### 5. Configuration

```xml
<!-- Only parsed in lab builds -->
<LabMode>
    <UseNextPacketTimestamp>true</UseNextPacketTimestamp>
</LabMode>
```

## Sequence Flow

```mermaid
sequenceDiagram
    participant RF as Replay Feed
    participant FW as Framework
    participant HC as Historical Clock
    participant TM as Timer Manager
    participant S as Strategy
    
    Note over HC: Lab Build Only
    
    RF->>FW: MDBBOEvent {<br/>exchange_time: 1000ms,<br/>nextPacketTimestamp: 2000ms}
    FW->>HC: advanceTime(1000ms)
    FW->>TM: nextTimerExpired()?
    TM->>HC: now()
    HC-->>TM: 1000ms
    
    alt Next Packet TS Available
        FW->>TM: expire(1999ms)
        Note over TM: Fire all timers with<br/>expiry <= 1999ms
        TM->>S: onTimer() // Timer at 1500ms
        Note over S: Timer fires at correct<br/>historical time
    else No Next Packet TS
        FW->>TM: expire(1000ms)
        Note over TM: Only fires timers <= 1000ms
    end
    
    FW->>S: on_market_data(snapshot)
```

## Build Process

```bash
# Production build (default, unchanged)
make gtad

# Lab build with historical clock
make gtad-lab   # Automatically adds -DGTAD_LAB_BUILD

# Deployment
production/bin/gtad      # Real clock, no historical features
lab/bin/gtad-lab         # Historical clock, requires GTAD_LAB_MODE=1
```

## Testing Strategy

1. **Unit Tests**: Verify historical clock advances correctly, timers fire at right times
2. **Integration Tests**: Replay same scenario with and without next packet timestamps
3. **Latency Verification**: Confirm timer-triggered orders show correct historical latency
4. **Safety Tests**: Verify lab binary refuses to run without proper environment

## Summary

This implementation provides:
- **Accurate timer replay** for latency analysis via historical clock
- **Zero production impact** through compile-time separation
- **Minimal code changes** with a single `#ifdef GTAD_LAB_BUILD`
- **Strong safety guarantees** preventing lab binary from running in production
- **Fire between packets** capability using next packet timestamp information

The approach maintains clean separation between production and lab code while enabling accurate historical replay for latency analysis.
